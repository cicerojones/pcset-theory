* babel documentation--added when?
* some of this may be obsolete
** basic utilities

#+NAME list+ adds an integer to each member of a list
#+BEGIN_SRC lisp
(list+ 1 '(0 1 2))
(1 2 3)
#+END_SRC

#+BEGIN_SRC lisp
(Tn1-11 1 '(0 1 2))
((1 2 3) (0 1 2))
#+END_SRC


#+BEGIN_SRC lisp
(mod12 '(0 12 24))
(0 0 0)
#+END_SRC


#+BEGIN_SRC lisp
(mod12-all '((0 12 24) (1 13 25)))
((0 0 0) (1 1 1))
#+END_SRC


#+BEGIN_SRC lisp
(TnI-all '((0 1 2)))
(((0 1 2) (1 2 3) (2 3 4) (3 4 5) (4 5 6) (5 6 7) (6 7 8) (7 8 9) (8
9 10) (9 10 11) (10 11 0) (11 0 1)))
#+END_SRC


#+BEGIN_SRC lisp
(flatten '((0 1 2) ((1 2 3) (1) 2) (((0 1) (0 2) ((1 (10)) 1900) (1000 13)) 24)))
(0 1 2 1 2 3 1 2 0 1 0 2 1 10 1900 1000 13 24)
#+END_SRC


#+BEGIN_SRC lisp
(count-occurrences '(0 0 0 1 2 2 4 4 5 5 5 5 ))
(3 1 2 0 2 4 0 0 0 0 0 0)
#+END_SRC


#+BEGIN_SRC lisp
(counting '(3 1 2 0 2 4 0 0 0 0 0 0))
(7 1 2 1 1 0 0 0 0 0 0 0)
#+END_SRC


#+BEGIN_SRC lisp
(repeating 10 1)
(1 1 1 1 1 1 1 1 1 1)
#+END_SRC


#+BEGIN_SRC lisp
(12-profile '(7 1 2
#+END_SRC 1 1 0 0 0 0 0 0 0))
((0 0 0 0 0 0 0) (1) (2 2) (3) (4) NIL NIL NIL NIL NIL NIL NIL)


#+BEGIN_SRC lisp
(clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11))
(1 2 3 3 4 4 4 5 5 5 6 6 6 7 7 7 7 7 8 8 8 8 8 8 8 10 10 10 10 10 10
10 10 10 10 11 11 11 11 11 11 11 11 11 11 11)
#+END_SRC


#+BEGIN_SRC lisp
(pc-compari 0 12)
12
#+END_SRC


#+BEGIN_SRC lisp
(rec-do-pc-compari '(0 1 2) '(0 1 3))
((0 11 10) (1 0 11) (3 2 1))
#+END_SRC


#+BEGIN_SRC lisp
(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
((0 1 2) (0 1 2) (0 1 2) (0 4) (0 1 2) (0 1 2 4 6))
#+END_SRC


#+BEGIN_SRC lisp
(set-up-all '(0 1))
(subseq (set-up-all '(0 1)) 0 21)
((0 1) (0 1) (0 1) (0 2) (0 1) (0 3) (0 1) (0 4) (0 1) (0 5) (0 1) (0 6) (0 1) (0 1 2) (0 1) (0 1 3) (0 1) (0 2 3) (0 1) (0 1 4) (0 1)) 
#+END_SRC


#+BEGIN_SRC lisp

(set-up-allA)
(subseq (set-up-allA '(0 1)) 0 21)
((0 1) (0 1) (0 1) (0 2) (0 1) (0 3) (0 1) (0 4) (0 1) (0 5) (0 1) (0 6) (0 1) (0 1 2) (0 1) (0 1 3) (0 1) (0 1 4) (0 1) (0 1 5) (0 1))
#+END_SRC


#+BEGIN_SRC lisp
(make-pairs-from-list '(0 1 2 3 4 5 6 7 8 9))
((0 1) (2 3) (4 5) (6 7) (8 9))
#+END_SRC


#+BEGIN_SRC lisp
(pair-all-x-y-forms '(0 1))
(subseq (pair-all-x-y-forms '(0 1)) 0 21)
(((0 1) (0 1))
 ((0 1) (0 2))
 ((0 1) (0 3))
 ((0 1) (0 4))
 ((0 1) (0 5))
 ((0 1) (0 6))
 ((0 1) (0 1 2))
 ((0 1) (0 1 3))
 ((0 1) (0 2 3))
 ((0 1) (0 1 4))
 ((0 1) (0 3 4))
 ((0 1) (0 1 5))
 ((0 1) (0 4 5))
 ((0 1) (0 1 6))
 ((0 1) (0 5 6))
 ((0 1) (0 2 4))
 ((0 1) (0 2 5))
 ((0 1) (0 3 5))
 ((0 1) (0 2 6))
 ((0 1) (0 4 6))
 ((0 1) (0 2 7))
)
#+END_SRC



#+BEGIN_SRC lisp
(pair-all-x-y-formsA '(0 1))
(subseq (pair-all-x-y-formsA '(0 1)) 0 21)
(((0 1) (0 1))
 ((0 1) (0 2))
 ((0 1) (0 3))
 ((0 1) (0 4))
 ((0 1) (0 5))
 ((0 1) (0 6))
 ((0 1) (0 1 2))
 ((0 1) (0 1 3))
 ((0 1) (0 1 4))
 ((0 1) (0 1 5))
 ((0 1) (0 1 6))
 ((0 1) (0 2 4))
 ((0 1) (0 2 5))
 ((0 1) (0 2 6))
 ((0 1) (0 2 7))
 ((0 1) (0 3 6))
 ((0 1) (0 3 7))
 ((0 1) (0 4 8))
 ((0 1) (0 1 2 3))
 ((0 1) (0 1 2 4))
 ((0 1) (0 1 3 4)))
#+END_SRC
** address cardinality issues
#+BEGIN_SRC lisp
(pair-x-y-forms-same-cardinality '(0 1 2))
(((0 1 2) (0 1 2)) ((0 1 2) (0 1 3)) ((0 1 2) (0 2 3)) ((0 1 2) (0 1
4)) ((0 1 2) (0 3 4)) ((0 1 2) (0 1 5)) ((0 1 2) (0 4 5)) ((0 1 2) (0
1 6)) ((0 1 2) (0 5 6)) ((0 1 2) (0 2 4)) ((0 1 2) (0 2 5)) ((0 1 2)
(0 3 5)) ((0 1 2) (0 2 6)) ((0 1 2) (0 4 6)) ((0 1 2) (0 2 7)) ((0
1 2) (0 3 6)) ((0 1 2) (0 3 7)) ((0 1 2) (0 4 7)) ((0 1 2) (0 4 8)))
#+END_SRC



#+BEGIN_SRC lisp
(pair-x-y-forms-same-cardinalityA '(0 1 2))
(((0 1 2) (0 1 2)) ((0 1 2) (0 1 3)) ((0 1 2) (0 1 4)) ((0 1 2) (0 1
5)) ((0 1 2) (0 1 6)) ((0 1 2) (0 2 4)) ((0 1 2) (0 2 5)) ((0 1 2) (0
2 6)) ((0 1 2) (0 2 7)) ((0 1 2) (0 3 6)) ((0 1 2) (0 3 7)) ((0 1 2)
(0 4 8)))
#+END_SRC


#+BEGIN_SRC lisp
(set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))
((0 1) (0 2) (0 1) (1 3) (0 1) (2 4) (0 1) (3 5) (0 1) (4 6) (0 1)
(5 7) (0 1) (6 8) (0 1) (7 9) (0 1) (8 10) (0 1) (9 11) (0 1) (10 0)
(0 1) (11 1))
#+END_SRC 


#+BEGIN_SRC lisp
'(create-lewin-vector '(0 1) '(0 2))
(1 1 1 0 0 0 0 0 0 0 0 1)
#+END_SRC


#+BEGIN_SRC lisp
(create-straus-profile '(0 1) '(0 2))
(0 1 2 11)
#+END_SRC


#+BEGIN_SRC lisp
(create-12-straus-profiles '(0 1) '(0 2))
((0 1 2 11) (0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (4 5 6 7) (5 6
7 8) (6 7 8 9) (7 8 9 10) (8 9 10 11) (0 9 10 11) (0 1 10 11))
#+END_SRC


#+BEGIN_SRC lisp
(create-12-lewin-vectors '(0 1) '(0 2))
((1 1 1 0 0 0 0 0 0 0 0 1) (1 1 1 1 0 0 0 0 0 0 0 0) (0 1 1 1 1 0 0 0
0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 0 0
1 1 1 1 0 0 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 0 0 1 1 1 1 0 0)
(0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 0 0 1 1 1 1) (1 0 0 0 0 0 0 0 0
1 1 1) (1 1 0 0 0 0 0 0 0 0 1 1))
#+END_SRC

** calculate weigthed sums
#+BEGIN_SRC lisp
(orzo-sum '(1 1 1 0 0 0 0 0 0 0 0 1))
11.455319
#+END_SRC

#+BEGIN_SRC lisp
(orzo-sumA '(1 1 1 0 0 0 0 0 0 0 0 1))
285311670744
#+END_SRC

#+BEGIN_SRC lisp
(embed-orzo-sums-with-straus-profiles '(0 1) '(0 2))
((285311670744 (0 1 2 11)) (1464 (0 1 2 3)) (16104 (1 2 3 4)) (177144
(2 3 4 5)) (1948584 (3 4 5 6)) (21434424 (4 5 6 7)) (235778664 (5 6 7
8)) (2593565304 (6 7 8 9)) (28529218344 (7 8 9 10)) (313821401784 (8 9
10 11)) (313607042904 (0 9 10 11)) (311249095224 (0 1 10 11)))
#+END_SRC

#+BEGIN_SRC lisp
(sigma '(0 1))
(subseq (sigma '(0 1)) 0 1)
(((0 1) (0 1) ((285311670624 (0 0 1 11)) (144 (0 1 1 2)) (1584 (1 2 2 3)) (17424 (2 3 3 4)) (191664 (3 4 4 5)) (2108304 (4 5 5 6)) (23191344
(5 6 6 7)) (255104784 (6 7 7 8)) (2806152624 (7 8 8 9)) (30867678864
(8 9 9 10)) (339544467504 (9 10 10 11)) (596560765824 (0 10 11 11)))))
#+END_SRC

#+BEGIN_SRC lisp
(tau '(0 1))
(subseq (tau '(0 1)) 0 9)

(((0 1) (0 1) ((285311670624 (0 0 1 11)) (144 (0 1 1 2)) (1584 (1 2 2
3)) (17424 (2 3 3 4)) (191664 (3 4 4 5)) (2108304 (4 5 5 6)) (23191344
(5 6 6 7)) (255104784 (6 7 7 8)) (2806152624 (7 8 8 9)) (30867678864
(8 9 9 10)) (339544467504 (9 10 10 11)) (596560765824 (0 10 11 11))))
((0 1) (0 2) ((285311670744 (0 1 2 11)) (1464 (0 1 2 3)) (16104 (1 2 3
4)) (177144 (2 3 4 5)) (1948584 (3 4 5 6)) (21434424 (4 5 6 7))
(235778664 (5 6 7 8)) (2593565304 (6 7 8 9)) (28529218344 (7 8 9 10))
(313821401784 (8 9 10 11)) (313607042904 (0 9 10 11)) (311249095224 (0
1 10 11)))) ((0 1) (0 3) ((285311672064 (0 2 3 11)) (15984 (0 1 3 4))
(175824 (1 2 4 5)) (1934064 (2 3 5 6)) (21274704 (3 4 6 7)) (234021744
(4 5 7 8)) (2574239184 (5 6 8 9)) (28316631024 (6 7 9 10))
(311482941264 (7 8 10 11)) (287883977184 (0 8 9 11)) (28295372304 (0 1
9 10)) (311249095344 (1 2 10 11)))) ((0 1) (0 4) ((285311686584 (0 3 4
11)) (175704 (0 1 4 5)) (1932744 (1 2 5 6)) (21260184 (2 3 6 7))
(233862024 (3 4 7 8)) (2572482264 (4 5 8 9)) (28297304904 (5 6 9 10))
(311270353944 (6 7 10 11)) (285545516664 (0 7 8 11)) (2572306584 (0 1
8 9)) (28295372424 (1 2 9 10)) (311249096664 (2 3 10 11)))) ((0 1)
(0 5) ((285311846304 (0 4 5 11)) (1932624 (0 1 5 6)) (21258864 (1 2 6
7)) (233847504 (2 3 7 8)) (2572322544 (3 4 8 9)) (28295547984 (4 5 9
10)) (311251027824 (5 6 10 11)) (285332929344 (0 6 7 11)) (233846064
(0 1 7 8)) (2572306704 (1 2 8 9)) (28295373744 (2 3 9 10))
(311249111184 (3 4 10 11)))) ((0 1) (0 6) ((285313603224 (0 5 6 11))
(21258744 (0 1 6 7)) (233846184 (1 2 7 8)) (2572308024 (2 3 8 9))
(28295388264 (3 4 9 10)) (311249270904 (4 5 10 11)) (285313603224 (0 5
6 11)) (21258744 (0 1 6 7)) (233846184 (1 2 7 8)) (2572308024 (2 3 8
9)) (28295388264 (3 4 9 10)) (311249270904 (4 5 10 11)))) ((0 1) (0
1 2) ((285311670756 (0 0 1 1 2 11)) (1596 (0 1 1 2 2 3)) (17556 (1 2 2
3 3 4)) (193116 (2 3 3 4 4 5)) (2124276 (3 4 4 5 5 6)) (23367036 (4 5
5 6 6 7)) (257037396 (5 6 6 7 7 8)) (2827411356 (6 7 7 8 8 9))
(31101524916 (7 8 8 9 9 10)) (342116774076 (8 9 9 10 10 11))
(624856138116 (0 9 10 10 11 11)) (596560765836 (0 0 1 10 11 11))))
((0 1) (0 1 3) ((285311672076 (0 0 1 2 3 11)) (16116 (0 1 1 2 3 4))
(177276 (1 2 2 3 4 5)) (1950036 (2 3 3 4 5 6)) (21450396 (3 4 4 5 6
7)) (235954356 (4 5 5 6 7 8)) (2595497916 (5 6 6 7 8 9)) (28550477076
(6 7 7 8 9 10)) (314055247836 (7 8 8 9 10 11)) (316179349476 (0 8 9 9
10 11)) (339544467516 (0 1 9 10 10 11)) (596560765956 (0 1 2 10 11
11)))) ((0 1) (0 1 4) ((285311686596 (0 0 1 3 4 11)) (175836 (0 1 1 2
4 5)) (1934196 (1 2 2 3 5 6)) (21276156 (2 3 3 4 6 7)) (234037716 (3 4
4 5 7 8)) (2574414876 (4 5 5 6 8 9)) (28318563636 (5 6 6 7 9 10))
(311504199996 (6 7 7 8 10 11)) (288117823236 (0 7 8 8 9 11))
(30867678876 (0 1 8 9 9 10)) (339544467636 (1 2 9 10 10 11))
(596560767276 (0 2 3 10 11 11)))))
#+END_SRC


#+BEGIN_SRC lisp
;avoid calling this function casually!
(upsilon *x-yA*)

;here's a peek

(subseq (upsilon *x-yA*) 0 9)
(((0 1) (0 1) ((285311670624 (0 0 1 11)) (144 (0 1 1 2)) (1584 (1 2 2 3)) (17424 (2 3 3 4)) (191664 (3 4 4 5)) (2108304 (4 5 5 6)) (23191344 (5 6 6 7)) (255104784 (6 7 7 8)) (2806152624 (7 8 8 9)) (30867678864 (8 9 9 10)) (339544467504 (9 10 10 11)) (596560765824 (0 10 11 11))))
 ((0 1) (0 2) ((285311670744 (0 1 2 11)) (1464 (0 1 2 3)) (16104 (1 2 3 4)) (177144 (2 3 4 5)) (1948584 (3 4 5 6)) (21434424 (4 5 6 7)) (235778664 (5 6 7 8)) (2593565304 (6 7 8 9)) (28529218344 (7 8 9 10)) (313821401784 (8 9 10 11)) (313607042904 (0 9 10 11)) (311249095224 (0 1 10 11))))
 ((0 1) (0 3) ((285311672064 (0 2 3 11)) (15984 (0 1 3 4)) (175824 (1 2 4 5)) (1934064 (2 3 5 6)) (21274704 (3 4 6 7)) (234021744 (4 5 7 8)) (2574239184 (5 6 8 9)) (28316631024 (6 7 9 10)) (311482941264 (7 8 10 11)) (287883977184 (0 8 9 11)) (28295372304 (0 1 9 10)) (311249095344 (1 2 10 11))))
 ((0 1) (0 4) ((285311686584 (0 3 4 11)) (175704 (0 1 4 5)) (1932744 (1 2 5 6)) (21260184 (2 3 6 7)) (233862024 (3 4 7 8)) (2572482264 (4 5 8 9)) (28297304904 (5 6 9 10)) (311270353944 (6 7 10 11)) (285545516664 (0 7 8 11)) (2572306584 (0 1 8 9)) (28295372424 (1 2 9 10)) (311249096664 (2 3 10 11))))
 ((0 1) (0 5) ((285311846304 (0 4 5 11)) (1932624 (0 1 5 6)) (21258864 (1 2 6 7)) (233847504 (2 3 7 8)) (2572322544 (3 4 8 9)) (28295547984 (4 5 9 10)) (311251027824 (5 6 10 11)) (285332929344 (0 6 7 11)) (233846064 (0 1 7 8)) (2572306704 (1 2 8 9)) (28295373744 (2 3 9 10)) (311249111184 (3 4 10 11)))) ((0 1) (0 6) ((285313603224 (0 5 6 11)) (21258744 (0 1 6 7)) (233846184 (1 2 7 8)) (2572308024 (2 3 8 9)) (28295388264 (3 4 9 10)) (311249270904 (4 5 10 11)) (285313603224 (0 5 6 11)) (21258744 (0 1 6 7)) (233846184 (1 2 7 8)) (2572308024 (2 3 8 9)) (28295388264 (3 4 9 10)) (311249270904 (4 5 10 11)))) ((0 1) (0 1 2) ((285311670756 (0 0 1 1 2 11)) (1596 (0 1 1 2 2 3)) (17556 (1 2 2 3 3 4)) (193116 (2 3 3 4 4 5)) (2124276 (3 4 4 5 5 6)) (23367036 (4 5 5 6 6 7)) (257037396 (5 6 6 7 7 8)) (2827411356 (6 7 7 8 8 9)) (31101524916 (7 8 8 9 9 10)) (342116774076 (8 9 9 10 10 11)) (624856138116 (0 9 10 10 11 11)) (596560765836 (0 0 1 10 11 11)))) ((0 1) (0 1 3) ((285311672076 (0 0 1 2 3 11)) (16116 (0 1 1 2 3 4)) (177276 (1 2 2 3 4 5)) (1950036 (2 3 3 4 5 6)) (21450396 (3 4 4 5 6 7)) (235954356 (4 5 5 6 7 8)) (2595497916 (5 6 6 7 8 9)) (28550477076 (6 7 7 8 9 10)) (314055247836 (7 8 8 9 10 11)) (316179349476 (0 8 9 9 10 11)) (339544467516 (0 1 9 10 10 11)) (596560765956 (0 1 2 10 11 11)))) ((0 1) (0 1 4) ((285311686596 (0 0 1 3 4 11)) (175836 (0 1 1 2 4 5)) (1934196 (1 2 2 3 5 6)) (21276156 (2 3 3 4 6 7)) (234037716 (3 4 4 5 7 8)) (2574414876 (4 5 5 6 8 9)) (28318563636 (5 6 6 7 9 10)) (311504199996 (6 7 7 8 10 11)) (288117823236 (0 7 8 8 9 11)) (30867678876 (0 1 8 9 9 10)) (339544467636 (1 2 9 10 10 11)) (596560767276 (0 2 3 10 11 11)))))

#+END_SRC


#+BEGIN_SRC lisp
(collect-cars-test (subseq (tau '(0 1)) 0 10))
((0 1) (0 1) (0 1) (0 1) (0 1) (0 1) (0 1) (0 1) (0 1) (0 1))
#+END_SRC



#+BEGIN_SRC lisp
(delta-light '((0 1) (1 2) (40 12300)))
(0 1 40)

(delta-light '((2 1) (0 2) (40 12300)))
(0 2 40)
#+END_SRC



#+BEGIN_SRC lisp
(gamma-light '(0 1) 'tau)
(subseq (gamma-light '(0 1) 'tau) 0 10)
(((285311670624 (0 0 1 11)) (144 (0 1 1 2)) (1584 (1 2 2 3)) (17424 (2 3 3 4)) (191664 (3 4 4 5)) (2108304 (4 5 5 6)) (23191344 (5 6 6 7)) (255104784 (6 7 7 8)) (2806152624 (7 8 8 9)) (30867678864 (8 9 9 10)) (339544467504 (9 10 10 11)) (596560765824 (0 10 11 11))) ((285311670744 (0 1 2 11)) (1464 (0 1 2 3)) (16104 (1 2 3 4)) (177144 (2 3 4 5)) (1948584 (3 4 5 6)) (21434424 (4 5 6 7)) (235778664 (5 6 7 8)) (2593565304 (6 7 8 9)) (28529218344 (7 8 9 10)) (313821401784 (8 9 10 11)) (313607042904 (0 9 10 11)) (311249095224 (0 1 10 11))) ((285311672064 (0 2 3 11)) (15984 (0 1 3 4)) (175824 (1 2 4 5)) (1934064 (2 3 5 6)) (21274704 (3 4 6 7)) (234021744 (4 5 7 8)) (2574239184 (5 6 8 9)) (28316631024 (6 7 9 10)) (311482941264 (7 8 10 11)) (287883977184 (0 8 9 11)) (28295372304 (0 1 9 10)) (311249095344 (1 2 10 11))) ((285311686584 (0 3 4 11)) (175704 (0 1 4 5)) (1932744 (1 2 5 6)) (21260184 (2 3 6 7)) (233862024 (3 4 7 8)) (2572482264 (4 5 8 9)) (28297304904 (5 6 9 10)) (311270353944 (6 7 10 11)) (285545516664 (0 7 8 11)) (2572306584 (0 1 8 9)) (28295372424 (1 2 9 10)) (311249096664 (2 3 10 11))) ((285311846304 (0 4 5 11)) (1932624 (0 1 5 6)) (21258864 (1 2 6 7)) (233847504 (2 3 7 8)) (2572322544 (3 4 8 9)) (28295547984 (4 5 9 10)) (311251027824 (5 6 10 11)) (285332929344 (0 6 7 11)) (233846064 (0 1 7 8)) (2572306704 (1 2 8 9)) (28295373744 (2 3 9 10)) (311249111184 (3 4 10 11))) ((285313603224 (0 5 6 11)) (21258744 (0 1 6 7)) (233846184 (1 2 7 8)) (2572308024 (2 3 8 9)) (28295388264 (3 4 9 10)) (311249270904 (4 5 10 11)) (285313603224 (0 5 6 11)) (21258744 (0 1 6 7)) (233846184 (1 2 7 8)) (2572308024 (2 3 8 9)) (28295388264 (3 4 9 10)) (311249270904 (4 5 10 11))) ((285311670756 (0 0 1 1 2 11)) (1596 (0 1 1 2 2 3)) (17556 (1 2 2 3 3 4)) (193116 (2 3 3 4 4 5)) (2124276 (3 4 4 5 5 6)) (23367036 (4 5 5 6 6 7)) (257037396 (5 6 6 7 7 8)) (2827411356 (6 7 7 8 8 9)) (31101524916 (7 8 8 9 9 10)) (342116774076 (8 9 9 10 10 11)) (624856138116 (0 9 10 10 11 11)) (596560765836 (0 0 1 10 11 11))) ((285311672076 (0 0 1 2 3 11)) (16116 (0 1 1 2 3 4)) (177276 (1 2 2 3 4 5)) (1950036 (2 3 3 4 5 6)) (21450396 (3 4 4 5 6 7)) (235954356 (4 5 5 6 7 8)) (2595497916 (5 6 6 7 8 9)) (28550477076 (6 7 7 8 9 10)) (314055247836 (7 8 8 9 10 11)) (316179349476 (0 8 9 9 10 11)) (339544467516 (0 1 9 10 10 11)) (596560765956 (0 1 2 10 11 11))) ((285311686596 (0 0 1 3 4 11)) (175836 (0 1 1 2 4 5)) (1934196 (1 2 2 3 5 6)) (21276156 (2 3 3 4 6 7)) (234037716 (3 4 4 5 7 8)) (2574414876 (4 5 5 6 8 9)) (28318563636 (5 6 6 7 9 10)) (311504199996 (6 7 7 8 10 11)) (288117823236 (0 7 8 8 9 11)) (30867678876 (0 1 8 9 9 10)) (339544467636 (1 2 9 10 10 11)) (596560767276 (0 2 3 10 11 11))) ((285311846316 (0 0 1 4 5 11)) (1932756 (0 1 1 2 5 6)) (21260316 (1 2 2 3 6 7)) (233863476 (2 3 3 4 7 8)) (2572498236 (3 4 4 5 8 9)) (28297480596 (4 5 5 6 9 10)) (311272286556 (5 6 6 7 10 11)) (285566775396 (0 6 7 7 8 11)) (2806152636 (0 1 7 8 8 9)) (30867678996 (1 2 8 9 9 10)) (339544468956 (2 3 9 10 10 11)) (596560781796 (0 3 4 10 11 11))))
#+END_SRC


#+BEGIN_SRC lisp
(extract-least-test '((1000 (em)) (10 (pansy division)) (1 (guy piccioto))))
(GUY PICCIOTO)
#+END_SRC



#+BEGIN_SRC lisp
(extract-least-upsilon '((10) (1000) ((1 100) (10000))))
(((10) (1000)) 100)
#+END_SRC


#+BEGIN_SRC lisp
(lambda-prime-form '(((1000 1234)) ((100000 2345))  ((12 3456))))
(1234 2345 3456)
#+END_SRC


#+BEGIN_SRC lisp
(lambda-prime-form (subseq (gamma-light '(0 1) 'tau) 0 10))
((0 1 1 2) (0 1 2 3) (0 1 3 4) (0 1 4 5) (0 1 5 6) (0 1 6 7) (0 1 1 2
2 3) (0 1 1 2 3 4) (0 1 1 2 4 5) (0 1 1 2 5 6))
#+END_SRC

;lambda prime form is key


#+BEGIN_SRC lisp
(compairings '((1 2) (1 3) (1 4) (1 2)))
(1 2)
#+END_SRC

(compairings '((1 2) (1 3) (1 4) (1 3)))
NIL


#+BEGIN_SRC lisp
(rec-compairings-A '((1 2) (1 3) (1 4) (1 2)))
((1 2) NIL NIL NIL)
#+END_SRC


#+BEGIN_SRC lisp
(rec-compairings-A '((1 2) (1 3) (1 4) (1 2) (1 4)))
((1 2) NIL (1 4) NIL NIL)
#+END_SRC


#+BEGIN_SRC lisp
(rec-compairings-A '((1 2) (1 3) (1 4) (1 2) (1 4) (1 4)))
((1 2) NIL (1 4) NIL (1 4) NIL)
#+END_SRC


#+BEGIN_SRC lisp
(multiple-parents '((0 6)))
(((0 1 6 7) (0 2 6 8) NIL NIL NIL NIL (0 1 2 6 7 8) (0 1 3 6 7 9) NIL
(0 1 2 6 7 8) NIL (0 2 4 6 8 10) (0 1 3 6 7 9) NIL NIL NIL NIL NIL (0
1 2 3 6 7 8 9) (0 1 2 4 6 7 8 10) (0 1 3 4 6 7 9 10) (0 1 2 3 6 7 8 9)
NIL (0 1 1 2 6 7 7 8) (0 1 2 3 6 7 8 9) NIL NIL (0 1 3 4 6 7 9 10) (0
1 2 4 6 7 8 10) NIL NIL (0 1 2 3 6 7 8 9) NIL NIL NIL (0 1 3 4 6 7
9 10) NIL (0 1 2 4 6 7 8 10) (0 1 2 3 6 7 8 9) (0 0 2 4 6 6 8 10) NIL
NIL NIL NIL NIL NIL NIL (0 1 2 3 4 6 7 8 9 10) (0 1 2 3 4 6 7 8 9 10)
(0 1 2 3 4 6 7 8 9 10) (0 0 1 2 3 6 6 7 8 9) (0 1 1 2 3 6 7 7 8 9) (0
1 1 2 3 6 7 7 8 9) NIL (0 0 2 3 4 6 6 8 9 10) (0 0 1 2 4 6 6 7 8 10)
(0 0 1 3 4 6 6 7 9 10) (0 1 2 3 4 6 7 8 9 10) (0 1 1 2 4 6 7 7 8 10)
(0 1 2 2 4 6 7 8 8 10) NIL NIL NIL (0 1 2 3 4 6 7 8 9 10) (0 1 2 3 3 6
7 8 9 9) NIL NIL (0 1 2 3 4 6 7 8 9 10) (0 1 1 2 4 6 7 7 8 10) (0 1 2
3 4 6 7 8 9 10) NIL (0 0 1 3 4 6 6 7 9 10) (0 0 2 3 4 6 6 8 9 10) (0 1
2 3 4 6 7 8 9 10) NIL NIL NIL NIL NIL NIL NIL (0 1 2 3 4 6 7 8 9 10)
NIL NIL NIL (0 1 2 3 4 5 6 7 8 9 10 11) (0 0 1 2 3 4 6 6 7 8 9 10) (0
1 1 2 3 4 6 7 7 8 9 10) (0 1 2 2 3 4 6 7 8 8 9 10) NIL (0 1 1 2 2 3 6
7 7 8 8 9) NIL (0 1 2 3 4 5 6 7 8 9 10 11) (0 1 2 2 3 4 6 7 8 8 9 10)
(0 1 2 3 4 4 6 7 8 9 10 10) (0 1 2 3 3 4 6 7 8 9 9 10) NIL (0 0 1 1 3
4 6 6 7 7 9 10) (0 1 2 3 4 5 6 7 8 9 10 11) (0 1 2 3 4 4 6 7 8 9
10 10) (0 1 2 2 3 4 6 7 8 8 9 10) NIL NIL (0 1 1 2 3 4 6 7 7 8 9 10)
(0 1 2 3 4 5 6 7 8 9 10 11) NIL NIL (0 1 1 3 3 4 6 7 7 9 9 10) (0 0 1
2 3 4 6 6 7 8 9 10) (0 1 1 2 3 4 6 7 7 8 9 10) (0 1 2 2 3 4 6 7 8 8
9 10) NIL (0 0 2 3 3 4 6 6 8 9 9 10) (0 0 1 2 3 3 6 6 7 8 9 9) NIL (0
1 2 3 4 4 6 7 8 9 10 10) NIL NIL NIL NIL (0 1 1 2 3 4 6 7 7 8 9 10) (0
1 2 2 3 4 6 7 8 8 9 10) NIL (0 0 1 2 3 4 6 6 7 8 9 10) NIL NIL NIL NIL
(0 1 1 2 3 4 6 7 7 8 9 10) NIL NIL NIL NIL NIL NIL))
#+END_SRC 


#+BEGIN_SRC lisp
(de-nestC '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7)))))
((0 1) (0 3) (0 4) (0 4 5) (0 4 6) (0 1 2 4) (0 1 3 5) (0 1 4 6) (0 2
5 7))
#+END_SRC


#+BEGIN_SRC lisp
(locate 10 '(0 100 10 1000 10 100000))
(10 3 5)
#+END_SRC 


#+BEGIN_SRC lisp
(map-locate '((0 1) (0 1 3) (0 1 4 6) (0 1 3) (0 1) (0 1) ((0 1 3))))
(((0 1) 1 5 6) ((0 1 3) 2 4) ((0 1 4 6) 3) ((0 1 3) 2 4) ((0 1) 1 5 6)
((0 1) 1 5 6) (((0 1 3)) 7))
#+END_SRC


#+BEGIN_SRC lisp
(jack-b '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
((0 (0 1)) (0 (0 3)) (0 (0 1 4)) (0 (0 1 5)) (0 (0 1)) (0 (0 3)))
#+END_SRC


#+BEGIN_SRC lisp
(jack-rec '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
(((0 (0 1)) (0 (0 3)) (0 (0 1 4)) (0 (0 1 5)) (0 (0 1)) (0 (0 3)))
(((1 (0 3)) (1 (0 1 4)) (1 (0 1 5)) (1 (0 1)) (1 (0 3))) NIL))
#+END_SRC

#+BEGIN_SRC lisp
(setq s1 '(0 1 3) s2 '(0 1 4))
(0 1 4)
#+END_SRC

#+BEGIN_SRC lisp
(invert-with-embed-orzo s1 s2)
(((2 2 0 1 1 0 0 0 0 1 1 1)
  (1 2 2 0 1 1 0 0 0 0 1 1)
  (1 1 2 2 0 1 1 0 0 0 0 1)
  (1 1 1 2 2 0 1 1 0 0 0 0)
  (0 1 1 1 2 2 0 1 1 0 0 0)
  (0 0 1 1 1 2 2 0 1 1 0 0)
  (0 0 0 1 1 1 2 2 0 1 1 0)
  (0 0 0 0 1 1 1 2 2 0 1 1)
  (1 0 0 0 0 1 1 1 2 2 0 1)
  (1 1 0 0 0 0 1 1 1 2 2 0)
  (0 1 1 0 0 0 0 1 1 1 2 2)
  (2 0 1 1 0 0 0 0 1 1 1 2))
 ((313607058899 (0 0 1 1 3 4 9 10 11)) (311249271169 (0 1 1 2 2 4 5 10 11)) (285313606139 (0 1 2 2 3 3 5 6 11)) (21290809 (0 1 2 3 3 4 4 6 7)) (234198899 (1 2 3 4 4 5 5 7 8)) (2576187889 (2 3 4 5 5 6 6 8 9)) (28338066779 (3 4 5 6 6 7 7 9 10)) (311718734569 (4 5 6 7 7 8 8 10 11)) (290477703539 (0 5 6 7 8 8 9 9 11)) (56826362209 (0 1 6 7 8 9 9 10 10)) (625089984299 (1 2 7 8 9 10 10 11 11)) (599133073849 (0 0 2 3 8 9 10 11 11))) ((0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0) (0 1 1 2 3 4 9 10 0)) ((0 1 2 7 8 10 10 11 11) (0 1 6 7 9 9 10 10 11) (0 5 6 8 8 9 9 10 11) (0 1 3 3 4 4 5 6 7) (0 1 3 3 4 4 5 6 7) (0 1 3 3 4 4 5 6 7) (0 1 3 3 4 4 5 6 7) (0 1 3 3 4 4 5 6 7) (0 2 2 3 3 4 5 6 11) (0 0 1 1 2 3 4 9 10) (0 0 1 1 2 3 4 9 10) (0 0 1 2 3 8 9 11 11)))
#+END_SRC


(let ((a '(0 1 3)) (b '(0 1 4)))
  (format t "~{~a ~a ~%~{~{~15a~}~%~}~}" (list a b (sort (embed-orzo-sums-with-straus-profiles '(0 1 3) '(0 1 4)) #'< :key #'car))))
(0 1 3) (0 1 4) 
21290809       (0 1 2 3 3 4 4 6 7)
234198899      (1 2 3 4 4 5 5 7 8)
2576187889     (2 3 4 5 5 6 6 8 9)
28338066779    (3 4 5 6 6 7 7 9 10)
56826362209    (0 1 6 7 8 9 9 10 10)
285313606139   (0 1 2 2 3 3 5 6 11)
290477703539   (0 5 6 7 8 8 9 9 11)
311249271169   (0 1 1 2 2 4 5 10 11)
311718734569   (4 5 6 7 7 8 8 10 11)
313607058899   (0 0 1 1 3 4 9 10 11)
599133073849   (0 0 2 3 8 9 10 11 11)
625089984299   (1 2 7 8 9 10 10 11 11)
NIL


#+BEGIN_SRC lisp
(find-prime-form-from-list '(11 0 1 4))
(11 0 1 4)
#+END_SRC


#+BEGIN_SRC lisp
(set-to-zero '(1 2 3 5))
(0 1 2 4)
#+END_SRC


#+BEGIN_SRC lisp
(invert-mod12-pcset '(0 3 7 10))
(0 2 5 9)
#+END_SRC

* more up-to-date
** figuring out how the latest prime-form code works


;; mod12math is different from mod12 how?
;; it involves some kind of subtraction that
;; ensures positive differences?



#+BEGIN_SRC lisp
(mapcar #'mod12math '(0 1 2 3 4 5 6) '(11 12 1 2 3 4 5))
(11 11 11 11 11 11 11)
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'mod12math '(0 1 2 3 4 5 6) '(1 2 3 4 5 6 7))
(1 1 1 1 1 1 1)
#+END_SRC


;; primer builds a list of differences between the respective
;; first and progressively inner terms, till it gets 
;; to the wasted value of itself with itself


;; note that it just looks you reverse things (and or transpose) until
;; you get to the last one, which ostensibly involves some
;; octave/mod12 shenanigans




#+BEGIN_SRC lisp
(mapcar #'primer '((0 1 5 6 8) (0 1 2) (0 3 7) (0 1 3 5) (1 4 7) (3 6 9 0)))
((8 6 5 1 0) (2 1 0) (7 3 0) (5 3 1 0) (6 3 0) (9 6 3 0))
#+END_SRC


;; prime-vector calls primer and then returns a version
;; of that output that discards the useless 0, and then
;; reorders the output to show the difference between the
;; next closest, and then next closest to that etc.


;; thus, we are coding: value of outer terms, and then
;; looking at "packedness to the left"
;; e.g. (a b c d)-> (d - a), (b - a), (c - a)


#+BEGIN_SRC lisp
(mapcar #'prime-vector '((0 1 5 6 8) (0 1 2) (0 3 7) (0 1 3 5) (1 4 7) (3 6 9 0)))
((8 1 5 6) (2 1) (7 3) (5 1 3) (6 3) (9 3 6))
#+END_SRC


;; wrap-vectors invokes prime-vector on all rotations of
;; the sample set. this allows us to see the option which
;; has the least distance between outer terms, and then
;; in case of ties, the smallest distance between the first
;; two terms




#+BEGIN_SRC lisp
(all-rotations '(0 1 5 6 8))
((0 1 5 6 8) (8 0 1 5 6) (6 8 0 1 5) (5 6 8 0 1) (1 5 6 8 0))
#+END_SRC


;; this combination:




#+BEGIN_SRC lisp
(mapcar #'prime-vector (all-rotations '(0 1 5 6 8)))
((8 1 5 6) (10 4 5 9) (11 2 6 7) (8 1 3 7) (11 4 5 7))
#+END_SRC


;;is the same as the following wrapper:




#+BEGIN_SRC lisp
(wrap-vectors '(0 1 5 6 8))
((8 1 5 6) (10 4 5 9) (11 2 6 7) (8 1 3 7) (11 4 5 7))
#+END_SRC


;; list-to-integer is a little hack that turns the list of integers
;; into a single integer in a kind of base-10, adding an extra zero at
;; the end


;; this makes it possible to compare lists and find the "smallest"
;; one. contrast this with the way an orzo-sum style of computation works




#+BEGIN_SRC lisp
(mapcar #'list-to-integer '((8 1 5 6) (10 4 5 9) (11 2 6 7) (8 1 3 7) (11 4 5 7)))
(81560 104590 112670 81370 114570)
#+END_SRC


;; see the following sequence of functions applications
;; to understand what find-prime-form-from-list is doing
(mapcar #'find-prime-form-from-list '((0 1 5 6 8) (



#+BEGIN_SRC lisp
(find-prime-form-from-list '(0 1 5 6 8))
(5 6 8 0 1)
#+END_SRC


;; FIRST: generate rotations


#+BEGIN_SRC lisp
(all-rotations '(0 1 5 6 8))
((0 1 5 6 8) (8 0 1 5 6) (6 8 0 1 5) (5 6 8 0 1) (1 5 6 8 0))
#+END_SRC


;; SECOND: create forte (or rahn) criteria, i.e. outer distance 
;; and packedness


#+BEGIN_SRC lisp
(mapcar #'prime-vector (all-rotations '(0 1 5 6 8)))
((8 1 5 6) (10 4 5 9) (11 2 6 7) (8 1 3 7) (11 4 5 7))
#+END_SRC


;; SECOND-A: convert list to integer


#+BEGIN_SRC lisp
(mapcar #'list-to-integer (mapcar #'prime-vector (all-rotations '(0 1 5 6 8))))
(81560 104590 112670 81370 114570)
#+END_SRC



(apply #'min '(81560 104590 112670 81370 114570))
81370



(position (apply #'min '(81560 104590 112670 81370 114570)) '(81560 104590 112670 81370 114570))
3


;; FINALLY: do the three above in one step as below.  i.e. 1. find the
;; smallest number, means find the rotation, which, when converted a
;; forte-susceptible form (smallest outer distance, smallest interval
;; from first note to second, smallest from first to third)


;; TELLS YOU WHERE TO LOOK (via #POSITION) in the original set of
;; rotations (via NTH of all-rotations


;; ERGO--this is a reduction of what find-prime-form-from-list does:



(nth 
 (position 
  (apply #'min '(81560 104590 112670 81370 114570)) 
  '(81560 104590 112670 81370 114570))
 (all-rotations '(0 1 5 6 8)))


(5 6 8 0 1)

;; THEN
;; transposes set down to zero
;; must perform certain bounds-checking to ensure
;; mod12 arithmetic


(set-to-zero '(5 6 8 0 1))
(0 1 3 7 8)

;;; things get a little confusing here--is for preparing
;;; and dealing with performing outright inversions
;;; not simply determining prime forms

;; invert-mod12-pcset doesn't quite do what I expect,
;; perhaps because of the sorting. compare the A-version

;;[0, 10, 8, 4] Put in numerical order:  [0, 4, 8, 10]


#+BEGIN_SRC lisp
(mapcar #'invert-mod12-pcset '((0 1 3) (0 1 4) (0 1 2 4) (0 1 3 7) (0 2 4 8) (0 1 3 7 8) (0 1 5 6 8) (0 1 5 7 8)))
((0 9 11) (0 8 11) (0 8 10 11) (0 5 9 11) (0 4 8 10) (0 4 5 9 11) (0 4
6 7 11) (0 4 5 7 11))
#+END_SRC




;; more obvious, simply build same intervals "down" (via a mod12)
;; as the ones that go up

#+BEGIN_SRC lisp
(mapcar #'Ainvert-mod12-pcset '((0 1 3) (0 1 4) (0 1 2 4) (0 1 3 7) (0 2 4 8) (0 1 3 7 8) (0 1 5 6 8) (0 1 5 7 8)))
((0 11 9) (0 11 8) (0 11 10 8) (0 11 9 5) (0 10 8 4) (0 11 9 5 4) (0
11 7 6 4) (0 11 7 5 4))
#+END_SRC



;; this is beautifully simple one that performs straightforwardly,
;; i.e. by making sure it performs set-to-zero

#+BEGIN_SRC lisp
(mapcar #'find-set-inversion '((5 6 8 0 1) (0 1 3 7 8) (0 3 7) (1 5 8)))
((0 1 5 7 8) (0 1 5 7 8) (0 4 7) (0 3 7))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'invert-set '((5 6 8 0 1) (0 1 3 7 8) (0 3 7) (1 5 8)))
((0 1 -7 -5 -4) (0 1 5 7 8) (0 4 7) (0 3 7))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'invert-set '((5 6 8 0 1) (1 2 4 8 9) (1 4 8) (6 11 2)))
((0 1 -7 -5 -4) (0 1 5 7 8) (0 4 7) (0 -9 -4))
#+END_SRC


;; forte-decision sets up for comparison the result of two kinds of
;; inversion?  it seems that there are unexpected results for say, (0 1 5 6 8),
;; a Rahn prime form turning into forte-preferred (0 1 3 7 8)


#+BEGIN_SRC lisp
(mapcar #'forte-decision '((0 1 5 6 8) (0 1 5 7 8) (0 2 3 6 7 9) (0 1 4 5 7 9) (0 1 3 5 8 9) (0 1 4 6 8 9) (0 1 2 5 6 7 9) (0 1 3 4 5 7 8 10)))
(((0 1 3 7 8) (0 1 5 7 8)) ((0 1 5 7 8) (0 1 3 7 8)) ((0 1 3 6 8 9) (0
1 3 6 8 9)) ((0 1 3 5 8 9) (0 1 4 6 8 9)) ((0 1 3 5 8 9) (0 1 4 6 8
9)) ((0 1 4 6 8 9) (0 1 3 5 8 9)) ((0 1 2 4 7 8 9) (0 1 2 5 7 8 9))
((0 1 2 4 5 7 9 10) (0 1 2 4 5 7 9 10)))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'(lambda (x) (set-to-zero (find-prime-form-from-list x))) '((0 1 5 6 8) (0 1 3 7 8) (0 1 5 7 8)))
((0 1 3 7 8) (0 1 3 7 8) (0 1 5 7 8))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'(lambda (x) (set-to-zero (find-prime-form-from-list (invert-mod12-pcset x)))) '((0 1 5 6 8) (0 1 3 7 8) (0 1 5 7 8)))
((0 1 5 7 8) (0 1 5 7 8) (0 1 3 7 8))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'(lambda (x) (set-to-zero (find-prime-form-from-list (Ainvert-mod12-pcset x)))) '((0 1 5 6 8) (0 1 3 7 8) (0 1 5 7 8)))
((0 8 7 5 1) (0 8 7 5 1) (0 8 6 5 1))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'forte-prime '((0 1 5 6 8) (0 1 3 7 8) (0 1 5 7 8)))
((0 1 3 7 8) (0 1 3 7 8) (0 1 3 7 8))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'find-set-inversion '((0 1 5 6 8) (0 1 3 7 8) (0 1 5 7 8)))
((0 2 3 7 8) (0 1 5 7 8) (0 1 3 7 8))
#+END_SRC


#+BEGIN_SRC lisp
(create-12-lewin-vectors '(0 2 6) '(0 3 7))
((1 2 0 1 0 1 1 1 0 1 1 0) (0 1 2 0 1 0 1 1 1 0 1 1) (1 0 1 2 0 1 0 1
1 1 0 1) (1 1 0 1 2 0 1 0 1 1 1 0) (0 1 1 0 1 2 0 1 0 1 1 1) (1 0 1 1
0 1 2 0 1 0 1 1) (1 1 0 1 1 0 1 2 0 1 0 1) (1 1 1 0 1 1 0 1 2 0 1 0)
(0 1 1 1 0 1 1 0 1 2 0 1) (1 0 1 1 1 0 1 1 0 1 2 0) (0 1 0 1 1 1 0 1 1
0 1 2) (2 0 1 0 1 1 1 0 1 1 0 1))
#+END_SRC


#+BEGIN_SRC lisp
(embed-orzo-sums-with-straus-profiles '(0 2 6) '(0 3 7))
((28316793429 (0 1 1 3 5 6 7 9 10)) (311484727719 (1 2 2 4 6 7 8 10
11)) (287903628189 (0 2 3 3 5 7 8 9 11)) (28511533359 (0 1 3 4 4 6 8 9
10)) (313626866949 (1 2 4 5 5 7 9 10 11)) (311467159719 (0 2 3 5 6 6 8
10 11)) (287710380189 (0 1 3 4 6 7 7 9 11)) (26385805359 (0 1 2 4 5 7
8 8 10)) (290243858949 (1 2 3 5 6 8 9 9 11)) (54254071719 (0 2 3 4 6 7
9 10 10)) (596794788909 (1 3 4 5 7 8 10 11 11)) (287885924559 (0 0 2 4
5 6 8 9 11)))
#+END_SRC


#+BEGIN_SRC lisp
(nconc (mapcar #'cadr (embed-orzo-sums-with-straus-profiles '(0 2 6) '(0 3 7))))
((0 1 1 3 5 6 7 9 10) (1 2 2 4 6 7 8 10 11) (0 2 3 3 5 7 8 9 11) (0 1
3 4 4 6 8 9 10) (1 2 4 5 5 7 9 10 11) (0 2 3 5 6 6 8 10 11) (0 1 3 4 6
7 7 9 11) (0 1 2 4 5 7 8 8 10) (1 2 3 5 6 8 9 9 11) (0 2 3 4 6 7 9
10 10) (1 3 4 5 7 8 10 11 11) (0 0 2 4 5 6 8 9 11))
#+END_SRC


#+BEGIN_SRC lisp
(mapcar #'forte-prime (nconc (mapcar #'cadr (embed-orzo-sums-with-straus-profiles '(0 2 6) '(0 3 7)))))
((0 1 3 4 6 7 8 10 0) (0 1 3 4 6 7 8 10 0) (0 1 3 4 6 7 8 10 0) (0 1 3
4 6 7 8 10 0) (0 1 3 4 6 7 8 10 0) (0 1 3 4 6 7 8 10 0) (0 1 3 4 6 7 8
10 0) (0 1 3 4 6 7 8 10 0) (0 1 3 4 6 7 8 10 0) (0 1 3 4 6 7 8 10 0)
(0 1 3 4 6 7 8 10 0) (0 1 3 4 6 7 8 10 0))
#+END_SRC

(format t "~{~{~a~%~} ~%~{~{~2a ~} ~%~}~%~}"(invertA-with-embed-orzo '(0 2 6) '(0 3 7)))
;;create-12-lewin-vectors
(1 2 0 1 0 1 1 1 0 1 1 0)
(0 1 2 0 1 0 1 1 1 0 1 1)
(1 0 1 2 0 1 0 1 1 1 0 1)
(1 1 0 1 2 0 1 0 1 1 1 0)
(0 1 1 0 1 2 0 1 0 1 1 1)
(1 0 1 1 0 1 2 0 1 0 1 1)
(1 1 0 1 1 0 1 2 0 1 0 1)
(1 1 1 0 1 1 0 1 2 0 1 0)
(0 1 1 1 0 1 1 0 1 2 0 1)
(1 0 1 1 1 0 1 1 0 1 2 0)
(0 1 0 1 1 1 0 1 1 0 1 2)
(2 0 1 0 1 1 1 0 1 1 0 1)

;;embed-orzo-sums-with-straus-profiles
28316793429 (0 1 1 3 5 6 7 9 10)  
311484727719 (1 2 2 4 6 7 8 10 11)  
287903628189 (0 2 3 3 5 7 8 9 11)  
28511533359 (0 1 3 4 4 6 8 9 10)  
313626866949 (1 2 4 5 5 7 9 10 11)  
311467159719 (0 2 3 5 6 6 8 10 11)  
287710380189 (0 1 3 4 6 7 7 9 11)  
26385805359 (0 1 2 4 5 7 8 8 10)  
290243858949 (1 2 3 5 6 8 9 9 11)  
54254071719 (0 2 3 4 6 7 9 10 10)  
596794788909 (1 3 4 5 7 8 10 11 11)  
287885924559 (0 0 2 4 5 6 8 9 11)  

;;#'multiset-forte-prime cadr embed-orzo-sums-with-straus-profiles
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
(0 1 2 4 5 7 8 10)
 
;;#'invert-set cadr embed-orzo-sums-with-straus-profiles
0  1  3  4  5  7  9  9  10  
0  1  3  4  5  7  9  9  10  
0  2  3  4  6  8  8  9  11  
0  1  2  4  6  6  7  9  10  
0  1  2  4  6  6  7  9  10  
0  1  3  5  5  6  8  9  11  
0  2  4  4  5  7  8  10 11  
0  2  2  3  5  6  8  9  10  
0  2  2  3  5  6  8  9  10  
0  0  1  3  4  6  7  8  10  
0  0  1  3  4  6  7  8  10  
0  2  3  5  6  7  9  11 11  

NIL




(testing-all3 '((0 2 6) (0 3 7)))

(testing-all2 '((0 2 6) (0 3 7)))

(let ((a '(0 2 6)) (b '(0 3 7)))
  (format t "~{~a ~a ~%~{~{~15a~}~%~}~}" (list a b (sort (embed-orzo-sums-with-straus-profiles '(0 1 3) '(0 1 4)) #'< :key #'car))))
(0 2 6) (0 3 7) 
21290809       (0 1 2 3 3 4 4 6 7)
234198899      (1 2 3 4 4 5 5 7 8)
2576187889     (2 3 4 5 5 6 6 8 9)
28338066779    (3 4 5 6 6 7 7 9 10)
56826362209    (0 1 6 7 8 9 9 10 10)
285313606139   (0 1 2 2 3 3 5 6 11)
290477703539   (0 5 6 7 8 8 9 9 11)
311249271169   (0 1 1 2 2 4 5 10 11)
311718734569   (4 5 6 7 7 8 8 10 11)
313607058899   (0 0 1 1 3 4 9 10 11)
599133073849   (0 0 2 3 8 9 10 11 11)
625089984299   (1 2 7 8 9 10 10 11 11)
NIL

(let ((a '(0 2 6)) (b '(0 3 7)))
  (format t "~{~a ~a ~%~{~{~15a~}~%~}~}" (list a b (sort
  (embed-orzo-sums-with-straus-profiles '(0 1 3) '(0 1 4)) #'< :key
  #'car))))
* pdf walk through of steps for given sets
** 013-0134
0. "imset-decision-maker" is the name of the program; it is being
invoked on the paired list of (013) and (0134) (CL-USER is the user
prompt, my interface with the engine that is the computer language,
Common Lisp, or CL)
CL-USER> (imset-decision-maker '((0 1 3) (0 1 3 4)))
1. here's X with its 12 transposed versions of Y
((0 1 3) (0 1 3 4))
((0 1 3) (1 2 4 5))
((0 1 3) (2 3 5 6))
((0 1 3) (3 4 6 7))
((0 1 3) (4 5 7 8))
((0 1 3) (5 6 8 9))
((0 1 3) (6 7 9 10))
((0 1 3) (7 8 10 11))
((0 1 3) (8 9 11 0))
((0 1 3) (9 10 0 1))
((0 1 3) (10 11 1 2))
((0 1 3) (11 0 2 3))
2. find the Lewin-IFUNC of these 12, and append to them the reverse of
those 12, which should cover X-Y when either are inverted
(3 2 1 2 1 0 0 0 0 1 1 1)
(1 3 2 1 2 1 0 0 0 0 1 1)
(1 1 3 2 1 2 1 0 0 0 0 1)
(1 1 1 3 2 1 2 1 0 0 0 0)
(0 1 1 1 3 2 1 2 1 0 0 0)
(0 0 1 1 1 3 2 1 2 1 0 0)
(0 0 0 1 1 1 3 2 1 2 1 0)
(0 0 0 0 1 1 1 3 2 1 2 1)
(1 0 0 0 0 1 1 1 3 2 1 2)
(2 1 0 0 0 0 1 1 1 3 2 1)
(1 2 1 0 0 0 0 1 1 1 3 2)
(2 1 2 1 0 0 0 0 1 1 1 3)
hence, these twelve are the IFUNCS for (023)*(0134)
(1 1 1 0 0 0 0 1 2 1 2 3)
(1 1 0 0 0 0 1 2 1 2 3 1)
(1 0 0 0 0 1 2 1 2 3 1 1)
(0 0 0 0 1 2 1 2 3 1 1 1)
(0 0 0 1 2 1 2 3 1 1 1 0)
(0 0 1 2 1 2 3 1 1 1 0 0)
(0 1 2 1 2 3 1 1 1 0 0 0)
(1 2 1 2 3 1 1 1 0 0 0 0)
(2 1 2 3 1 1 1 0 0 0 0 1)
(1 2 3 1 1 1 0 0 0 0 1 2)
(2 3 1 1 1 0 0 0 0 1 2 1)
(3 1 1 1 0 0 0 0 1 2 1 2)
which you can confirm here; note that the contents of the blue text
below are the same as the second group of 12 just above, though they
are listed in a different order, which is curious, but readily
confirmable
2.1 the program used here, "create-12-lewin-vectors,"
produces--unsurprisingly--the 12 lewin-vectors by transposing Y 12
times, shown here to increase transparency and confidence
CL-USER> (create-12-lewin-vectors '(0 2 3) '(0 1 3 4))
((2 3 1 1 1 0 0 0 0 1 2 1) (1 2 3 1 1 1 0 0 0 0 1 2) (2 1 2 3 1 1 1 0 0
0 0 1) (1 2 1 2 3 1 1 1 0 0 0 0) (0 1 2 1 2 3 1 1 1 0 0 0) (0 0 1 2 1 2
3 1 1 1 0 0) (0 0 0 1 2 1 2 3 1 1 1 0) (0 0 0 0 1 2 1 2 3 1 1 1) (1 0 0
0 0 1 2 1 2 3 1 1) (1 1 0 0 0 0 1 2 1 2 3 1) (1 1 1 0 0 0 0 1 2 1 2 3)
(3 1 1 1 0 0 0 0 1 2 1 2))
3. using the Lewin-style IFUNCs, create the Straus-style imsets,
proceeding in order down the big list of 24 IFUNCS produced in step 2,
i.e.
(0 0 0 1 1 2 3 3 4 9 10 11) = (3 2 1 2 1 0 0 0 0 1 1 1)
(0 1 1 1 2 2 3 4 4 5 10 11) = (1 3 2 1 2 1 0 0 0 0 1 1) etc.
(0 1 2 2 2 3 3 4 5 5 6 11)
(0 1 2 3 3 3 4 4 5 6 6 7)
(1 2 3 4 4 4 5 5 6 7 7 8)
(2 3 4 5 5 5 6 6 7 8 8 9)
(3 4 5 6 6 6 7 7 8 9 9 10)
(4 5 6 7 7 7 8 8 9 10 10 11)
(0 5 6 7 8 8 8 9 9 10 11 11)
(0 0 1 6 7 8 9 9 9 10 10 11)
(0 1 1 2 7 8 9 10 10 10 11 11)
(0 0 1 2 2 3 8 9 10 11 11 11)
(0 1 2 7 8 8 9 10 10 11 11 11)
(0 1 6 7 7 8 9 9 10 10 10 11)
(0 5 6 6 7 8 8 9 9 9 10 11)
(4 5 5 6 7 7 8 8 8 9 10 11)
(3 4 4 5 6 6 7 7 7 8 9 10)
(2 3 3 4 5 5 6 6 6 7 8 9)
(1 2 2 3 4 4 5 5 5 6 7 8)
(0 1 1 2 3 3 4 4 4 5 6 7)
(0 0 1 2 2 3 3 3 4 5 6 11)
(0 1 1 2 2 2 3 4 5 10 11 11)
(0 0 1 1 1 2 3 4 9 10 10 11)
(0 0 0 1 2 3 8 9 9 10 11 11)
4. determine the forte-prime form that results from following the
Robinson approach to the above list of multisets; printed vertically
here incidentally
0
1
2
3
4
5
6
7
below is the list of reduced multisets that comes from processing the
above; note there are TWO appearances of 01234567 in this case, though
they came from different multisets above. this relates to the
type/token distinction Robinson discusses. The ambiguity of
"reintroduce the doublings" seems problematic here.
(0 1 2 3 4 9 10 11)
(0 1 2 3 4 5 10 11)
(0 1 2 3 4 5 6 11)
*(0 1 2 3 4 5 6 7)*
(1 2 3 4 5 6 7 8)
(2 3 4 5 6 7 8 9)
(3 4 5 6 7 8 9 10)
(4 5 6 7 8 9 10 11)
(0 5 6 7 8 9 10 11)
(0 1 6 7 8 9 10 11)
(0 1 2 7 8 9 10 11)
(0 1 2 3 8 9 10 11)
(0 1 2 7 8 9 10 11)
(0 1 6 7 8 9 10 11)
(0 5 6 7 8 9 10 11)
(4 5 6 7 8 9 10 11)
(3 4 5 6 7 8 9 10)
(2 3 4 5 6 7 8 9)
(1 2 3 4 5 6 7 8)
*(0 1 2 3 4 5 6 7)*
(0 1 2 3 4 5 6 11)
(0 1 2 3 4 5 10 11)
(0 1 2 3 4 9 10 11)
(0 1 2 3 8 9 10 11)
5. report back on the appearances of chosen forte-prime form in the
above list; 4 and 20 are the locations (0 1 2 3 4 5 6 7) appear in the
list
(0 1 2 3 4 5 6 7)
4
20
6. find the generating, multiset parents of the prime form in question
(that is, (0 1 2 3 4 5 6 7) in this case), by looking back at the big
list created in step 3
(0 1 2 3 3 3 4 4 5 6 6 7)
(0 1 1 2 3 3 4 4 4 5 6 7)
6.1 note, these two things appear again because in this case there were
only two unique multiset parents; this is not always the case, as in
the next example
(0 1 2 3 3 3 4 4 5 6 6 7)
(0 1 1 2 3 3 4 4 4 5 6 7)

#+COMMENT More documentation of this step!
7. choose the best multiset from above, a process that can be a little
tricky; see next example
(0 1 1 2 3 3 4 4 4 5 6 7)
---------------------------------------------------------------------
** 036-0134
Here's the version of the same process from above, but now with two
symmetrical sets, (036) and (0134)
0.
CL-USER> (imset-decision-maker '((0 3 6) (0 1 3 4)))
1.
((0 3 6) (0 1 3 4))
((0 3 6) (1 2 4 5))
((0 3 6) (2 3 5 6))
((0 3 6) (3 4 6 7))
((0 3 6) (4 5 7 8))
((0 3 6) (5 6 8 9))
((0 3 6) (6 7 9 10))
((0 3 6) (7 8 10 11))
((0 3 6) (8 9 11 0))
((0 3 6) (9 10 0 1))
((0 3 6) (10 11 1 2))
((0 3 6) (11 0 2 3))
2. note that because both sets are symmetrical the step carried out
here of appending the reverse of each IFUNC produces redundancies;
however they are left in because it is procedurally simpler than
trying to get the program to distinguish between the two cases.
also note that the repetitive structure that characterizes the imset
is most evident in certain rotations of the basic IFUNC
(2 2 0 1 1 0 1 1 0 2 2 0)
(0 2 2 0 1 1 0 1 1 0 2 2)
(2 0 2 2 0 1 1 0 1 1 0 2)
e.g. *(2 2 0 2 2 0 1 1 0 1 1 0)*
(0 2 2 0 2 2 0 1 1 0 1 1)
(1 0 2 2 0 2 2 0 1 1 0 1)
(1 1 0 2 2 0 2 2 0 1 1 0)
(0 1 1 0 2 2 0 2 2 0 1 1)
(1 0 1 1 0 2 2 0 2 2 0 1)
(1 1 0 1 1 0 2 2 0 2 2 0)
(0 1 1 0 1 1 0 2 2 0 2 2)
(2 0 1 1 0 1 1 0 2 2 0 2)
(0 2 2 0 1 1 0 1 1 0 2 2)
(2 2 0 1 1 0 1 1 0 2 2 0)
(2 0 1 1 0 1 1 0 2 2 0 2)
(0 1 1 0 1 1 0 2 2 0 2 2)
(1 1 0 1 1 0 2 2 0 2 2 0)
(1 0 1 1 0 2 2 0 2 2 0 1)
(0 1 1 0 2 2 0 2 2 0 1 1)
(1 1 0 2 2 0 2 2 0 1 1 0)
(1 0 2 2 0 2 2 0 1 1 0 1)
(0 2 2 0 2 2 0 1 1 0 1 1)
(2 2 0 2 2 0 1 1 0 1 1 0)
(2 0 2 2 0 1 1 0 1 1 0 2)
3.
(0 0 1 1 3 4 6 7 9 9 10 10)
(1 1 2 2 4 5 7 8 10 10 11 11)
(0 0 2 2 3 3 5 6 8 9 11 11)
(0 0 1 1 3 3 4 4 6 7 9 10)
(1 1 2 2 4 4 5 5 7 8 10 11)
(0 2 2 3 3 5 5 6 6 8 9 11)
(0 1 3 3 4 4 6 6 7 7 9 10)
(1 2 4 4 5 5 7 7 8 8 10 11)
(0 2 3 5 5 6 6 8 8 9 9 11)
(0 1 3 4 6 6 7 7 9 9 10 10)
(1 2 4 5 7 7 8 8 10 10 11 11)
(0 0 2 3 5 6 8 8 9 9 11 11)
(1 1 2 2 4 5 7 8 10 10 11 11)
(0 0 1 1 3 4 6 7 9 9 10 10)
(0 0 2 3 5 6 8 8 9 9 11 11)
(1 2 4 5 7 7 8 8 10 10 11 11)
(0 1 3 4 6 6 7 7 9 9 10 10)
(0 2 3 5 5 6 6 8 8 9 9 11)
(1 2 4 4 5 5 7 7 8 8 10 11)
(0 1 3 3 4 4 6 6 7 7 9 10)
(0 2 2 3 3 5 5 6 6 8 9 11)
(1 1 2 2 4 4 5 5 7 8 10 11)
(0 0 1 1 3 3 4 4 6 7 9 10)
(0 0 2 2 3 3 5 6 8 9 11 11)
4.
0
1
3
4
6
7
9
10
now there are four!
*(0 1 3 4 6 7 9 10)*
(1 2 4 5 7 8 10 11)
(0 2 3 5 6 8 9 11)
*(0 1 3 4 6 7 9 10)*
(1 2 4 5 7 8 10 11)
(0 2 3 5 6 8 9 11)
*(0 1 3 4 6 7 9 10)*
(1 2 4 5 7 8 10 11)
(0 2 3 5 6 8 9 11)
*(0 1 3 4 6 7 9 10)*
(1 2 4 5 7 8 10 11)
(0 2 3 5 6 8 9 11)
(1 2 4 5 7 8 10 11)
(0 1 3 4 6 7 9 10)
(0 2 3 5 6 8 9 11)
(1 2 4 5 7 8 10 11)
(0 1 3 4 6 7 9 10)
(0 2 3 5 6 8 9 11)
(1 2 4 5 7 8 10 11)
(0 1 3 4 6 7 9 10)
(0 2 3 5 6 8 9 11)
(1 2 4 5 7 8 10 11)
(0 1 3 4 6 7 9 10)
(0 2 3 5 6 8 9 11)
5. note this prime form appears four times now at levels of
transposition that clearly relate to the imset itself. (if I used
zero-indexing, i.e. counting up from 0 rather than 1, the occurrences
below would show that the prime form appears above at T0, T3, T6 and T9)
(also note that the last four appearances--14, 17, 20, and 23--are, of
course, repetitions,
but are left in because they do no harm)
(0 1 3 4 6 7 9 10)
1
4
7
10
14
17
20
23
6. there is redundancy here, but it is a necessary byproduct of the
chosen procedure and is boiled down right below. note that this did
NOT happen when in the first example
(0 0 1 1 3 4 6 7 9 9 10 10)
(0 0 1 1 3 3 4 4 6 7 9 10)
(0 1 3 3 4 4 6 6 7 7 9 10)
(0 1 3 4 6 6 7 7 9 9 10 10)
(0 0 1 1 3 4 6 7 9 9 10 10)
(0 1 3 4 6 6 7 7 9 9 10 10)
(0 1 3 3 4 4 6 6 7 7 9 10)
(0 0 1 1 3 3 4 4 6 7 9 10)
6.1 four unique multisets which instantiate the forte-prime-form of (0 1
3 4 6 7 9 10)
(0 0 1 1 3 4 6 7 9 9 10 10)
(0 1 3 4 6 6 7 7 9 9 10 10)
(0 1 3 3 4 4 6 6 7 7 9 10)
(0 0 1 1 3 3 4 4 6 7 9 10)
7.
(0 0 1 1 3 3 4 4 6 7 9 10)

