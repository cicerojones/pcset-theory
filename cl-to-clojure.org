* converting basic common lisp functions to clojure
** basic "list adder" function
*** common lisp
#+BEGIN_SRC lisp :session cl-to-cloj
(defun list+ (n lst)
  (mapcar #'(lambda (x) (+ n x)) lst))

(list+ 12 '(0 4 7))
#+END_SRC

#+RESULTS:
| 12 | 16 | 19 |

*** clojure
#+BEGIN_SRC clojure :session cl-to-cloj
(defn list+ [n lst]
  (map (fn [x] (+ n x)) lst))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/list+

#+BEGIN_SRC clojure :session cl-to-cloj
(list+ 3 [1 2 3])
#+END_SRC

#+RESULTS:
| 4 | 5 | 6 |
** generate 12 transposition of a given set
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun Tn1-11 (n pcset)     ;expects an argument of n=12
    (cond ((= n -1) ())
	  (t (cons (list+ n pcset)
		   (Tn1-11 (- n 1) pcset)))))

(Tn1-11 12 '(0 4 7))
 #+END_SRC

 #+RESULTS:
 | 12 | 16 | 19 |
 | 11 | 15 | 18 |
 | 10 | 14 | 17 |
 |  9 | 13 | 16 |
 |  8 | 12 | 15 |
 |  7 | 11 | 14 |
 |  6 | 10 | 13 |
 |  5 |  9 | 12 |
 |  4 |  8 | 11 |
 |  3 |  7 | 10 |
 |  2 |  6 |  9 |
 |  1 |  5 |  8 |
 |  0 |  4 |  7 |
*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn Tn1-11 [pcset]
  (loop [n 12
         acc ()
         ]
    (if (< n 0)
      acc
      (recur (dec n) (conj acc (list+ n pcset))))))


#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/Tn1-11

#+BEGIN_SRC clojure :session cl-to-cloj
(Tn1-11 '(0 4 7))
#+END_SRC

#+RESULTS:
|  0 |  4 |  7 |
|  1 |  5 |  8 |
|  2 |  6 |  9 |
|  3 |  7 | 10 |
|  4 |  8 | 11 |
|  5 |  9 | 12 |
|  6 | 10 | 13 |
|  7 | 11 | 14 |
|  8 | 12 | 15 |
|  9 | 13 | 16 |
| 10 | 14 | 17 |
| 11 | 15 | 18 |
| 12 | 16 | 19 |

** mod12 across a list
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12 (lst)
  (mapcar #'(lambda (x) (mod x 12)) lst))

(mod12 '(24 28 31))
 #+END_SRC

 #+RESULTS:
 | 0 | 4 | 7 |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn mod12 [lst]
(map #(mod % 12) lst))

(mod12 [24 28 31])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/mod12(0 4 7)

** mod12 across nested lists

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12-all (lst-of-lsts)
  (mapcar #'mod12 lst-of-lsts))

(mod12-all '((24 28 31) (36 40 43)))
 #+END_SRC

 #+RESULTS:
 | 0 | 4 | 7 |
 | 0 | 4 | 7 |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn mod12-all [lst-of-lsts]
(map mod12 lst-of-lsts))

(mod12-all [[24 28 31] [36 40 43]])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/mod12-all((0 4 7) (0 4 7))

** generate transposed lists from list of prime form pcset

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun TnI-all (lol-of-pcsets)
 (mapcar #'(lambda (x) (reverse (mod12-all (Tn1-11 11 x)))) lol-of-pcsets))

(TnI-all '((0 1 2) (0 3 6)))
 #+END_SRC

 #+RESULTS:
 | (0 1 2) | (1 2 3) | (2 3 4) | (3 4 5) | (4 5 6)  | (5 6 7)  | (6 7 8) | (7 8 9)  | (8 9 10) | (9 10 11) | (10 11 0) | (11 0 1) |
 | (0 3 6) | (1 4 7) | (2 5 8) | (3 6 9) | (4 7 10) | (5 8 11) | (6 9 0) | (7 10 1) | (8 11 2) | (9 0 3)   | (10 1 4)  | (11 2 5) |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn TnI-all [lol-of-pcsets]
(map #(mod12-all (Tn1-11 %)) lol-of-pcsets))

(TnI-all [[0 1 2] [0 4 7]])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/TnI-all(((0 1 2) (1 2 3) (2 3 4) (3 4 5) (4 5 6) (5 6 7) (6 7 8) (7 8 9) (8 9 10) (9 10 11) (10 11 0) (11 0 1) (0 1 2)) ((0 4 7) (1 5 8) (2 6 9) (3 7 10) (4 8 11) (5 9 0) (6 10 1) (7 11 2) (8 0 3) (9 1 4) (10 2 5) (11 3 6) (0 4 7)))

** flatten already in clojure.core
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun flatten (x)
  (labels 
      ((rec (x acc) 
	 (cond ((null x) acc) 
	       ((atom x) (cons x acc)) 
	       (t (rec (car x) (rec (cdr x) acc))))))
    (rec x nil)))
 #+END_SRC

 #+RESULTS:
 : FLATTEN


 ;; (defun count-occurrences (vector-list)
 ;;   (cond ((null vector-list) ())
 ;; ;; expects only the 12 pitch classes
 ;; 	(t (list (count 0 vector-list)
 ;; 		 (count 1 vector-list)
 ;; 		 (count 2 vector-list)
 ;; 		 (count 3 vector-list)
 ;; 		 (count 4 vector-list)
 ;; 		 (count 5 vector-list)
 ;; 		 (count 6 vector-list)
 ;; 		 (count 7 vector-list)
 ;; 		 (count 8 vector-list)
 ;; 		 (count 9 vector-list)
 ;; 		 (count 10 vector-list)
 ;; 		 (count 11 vector-list)))))

 ;; this is an exhaustive version of COUNT that is also
 ;; recursive. why does it need to use LABELS? so you don't
 ;; have to explicitly pass in '11', or so you can call 
 ;; REVERSE at the end? Probably possible to write it more simply.

* bad imperative counting data vector constructing functions
** counting? counts occurrences of elements--interval vector func
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun counting (lst-of-12ints)
  "Use COUNT to find the number of occurrences of each
 member of the list"
  (labels ((count-up (n ints)
	     (cond ((< n 0) ())
		   (t (cons (count n ints)
			    (count-up (1- n) ints))))))
    ;; assumes you want to be looking at the twelve pitch-classes
    (reverse (count-up 11 lst-of-12ints))))


(counting '(3 1 2 0 2 4 0 0 0 0 0 0))
 #+END_SRC

 #+RESULTS:
 | 7 | 1 | 2 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |


#+BEGIN_SRC lisp :session cl-to-cloj
(count 12 '(12 0 1 2 12))
#+END_SRC

#+RESULTS:
: 2

*** clj--frequencies
**** produces a map??
#+BEGIN_SRC clojure :session cl-to-cloj :results output
(println (frequencies [3 1 2 0 2 4 0 0 0 0 0 0]))
#+END_SRC

#+RESULTS:
: {3 1, 1 1, 2 2, 0 7, 4 1}

**** clj--dealing with frequencies
#+BEGIN_SRC clojure :session cl-to-cloj
(let [v [3 1 2 0 2 4 0 0 0 0 0 0]]
                            (for [n (range 12)]
                              (get (frequencies v ) n 0)))
#+END_SRC

#+RESULTS:
| 7 | 1 | 2 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

*** clj--counting proper
#+BEGIN_SRC clojure :session cl-to-cloj
(defn counting [v]
  (for [n (range 12)]
    (get (frequencies v ) n 0)))
#+END_SRC  

#+RESULTS:
: #'post_tonal_overtone.core/counting

#+BEGIN_SRC clojure :session cl-to-cloj
(counting '(3 1 2 0 2 4 0 0 0 0 0 0))
#+END_SRC

#+RESULTS:
| 7 | 1 | 2 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

** repeat elements
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun repeating (num-element1 num-element2)
  (cond ((= 0 num-element1) ())
	(t (cons num-element2
		 (repeating (- num-element1 1) num-element2)))))

(repeating 4 6)
 #+END_SRC

 #+RESULTS:
 | 6 | 6 | 6 | 6 |

*** clj--repeat is a built-in for populating a list
#+BEGIN_SRC clojure :session cl-to-cloj
(repeat 4 6)
#+END_SRC

#+RESULTS:
| 6 | 6 | 6 | 6 |

** frequencies vs. fixed array?
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun 12-profile (vector)
  (list (repeating (nth 0 vector) 0)
	(repeating (nth 1 vector) 1)
	(repeating (nth 2 vector) 2)
	(repeating (nth 3 vector) 3)
	(repeating (nth 4 vector) 4)
	(repeating (nth 5 vector) 5)
	(repeating (nth 6 vector) 6)
	(repeating (nth 7 vector) 7)
	(repeating (nth 8 vector) 8)
	(repeating (nth 9 vector) 9)
	(repeating (nth 10 vector) 10)
	(repeating (nth 11 vector) 11)))

(12-profile (counting '(3 1 2 0 2 4 0 0 0 0 0 0)))
 #+END_SRC

 #+RESULTS:
 | (0 0 0 0 0 0 0) | (1) | (2 2) | (3) | (4) | NIL | NIL | NIL | NIL | NIL | NIL | NIL |

*** clj
**** contains? is best on maps, not lists or vectors
http://clojuredocs.org/clojure.core/contains_q

** "clean profile" flattens and removes nill
*** understanding what clean profile is doing
**** produce all intervals between two pcsets--rec-do-compari
#+BEGIN_SRC lisp :session cl-to-cloj
(flatten (rec-do-pc-compari '(0 1) '(0 1 2)))

#+END_SRC

#+RESULTS:
| 0 | 11 | 1 | 0 | 2 | 1 |

**** count up the appearances of the 12 pitch classes in that multiset--lewin
#+BEGIN_SRC lisp
(counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2))))
#+END_SRC

#+RESULTS:
| 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

#+BEGIN_SRC clojure
(counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2))))
#+END_SRC

#+RESULTS:
| 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

#+BEGIN_SRC lisp :session cl-to-cloj

#+END_SRC  

**** create-lewin-vector simply WRAPS counting--flatten--rec-do-pc-compari
#+BEGIN_SRC lisp :session cl-to-cloj
(defun create-lewin-vector (set1 set2)
  (counting (flatten (rec-do-pc-compari set1 set2))))
#+END_SRC

#+RESULTS:
: CREATE-LEWIN-VECTOR

#+BEGIN_SRC lisp
(counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2))))
#+END_SRC

#+RESULTS:
| 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

**** clean profile this vector == create-straus-profile
#+BEGIN_SRC lisp
(clean-profile (counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2)))))
#+END_SRC

#+RESULTS:
| 0 | 0 | 1 | 1 | 2 | 11 |



#+RESULTS:
: CREATE-STRAUS-PROFILE

**** clean-profile is the same as sorting the rec-do-pc-compari???
Why did I go through all that trouble? So that I had access to a lewin
vector if necessary?

Rec-do requires two sets, whereas clean-profile works on a lewin
vector. Is there any reason not to take the output of sorting the
flatten rec-do-compari and passing THAT?
#+BEGIN_SRC lisp :session cl-to-cloj
(sort (flatten (rec-do-pc-compari '(0 1) '(0 1 2))) #'<)
#+END_SRC

#+RESULTS:
| 0 | 0 | 1 | 1 | 2 | 11 |


**** [#B] two create-straus-profiles--only called by create-12-straus, which goes uncalled
#+BEGIN_SRC lisp :session cl-to-cloj
(defun create-straus-profile (set1 set2)
  (clean-profile (create-lewin-vector set1 set2)))

(create-straus-profile '(0 1) '(0 1 2))
#+END_SRC

#+RESULTS:
| 0 | 0 | 1 | 1 | 2 | 11 |

I.e. create-straus-profile is:


#+BEGIN_SRC lisp :session cl-to-cloj
(defun create-straus-profile (set1 set2)
  (sort (flatten (rec-do-pc-compari set1 set2)) #'<))

(create-straus-profile '(0 1) '(0 1 2))

#+END_SRC

#+RESULTS:
| 0 | 0 | 1 | 1 | 2 | 11 |

*** cl--may be largely unnecessary?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun clean-profile (single-vector)
  (flatten (remove-if #'null (12-profile single-vector))))

(clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11))

 #+END_SRC

 #+RESULTS:
 | 1 | 2 | 3 | 3 | 4 | 4 | 4 | 5 | 5 | 5 | 6 | 6 | 6 | 7 | 7 | 7 | 7 | 7 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 |

*** clj?--create straus profile directly
#+BEGIN_SRC clojure :session cl-to-cloj
(defn clean-profile [single-vector]
(sort (flatten (rec-do-pc-compari ))))
#+END_SRC
* the ever intriguing de-nesting problem
** de-nesting to one level
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun de-nestC (x)
  (labels ((rec (x acc)
	     (cond ((null x) acc)
		   ((atom (car x)) (cons x acc)) 
		   (t (rec (car x) (rec (cdr x) acc)))))) 
    (rec x nil)))

(de-nestC '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7)))))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |   |   |
 | 0 | 3 |   |   |
 | 0 | 4 |   |   |
 | 0 | 4 | 5 |   |
 | 0 | 4 | 6 |   |
 | 0 | 1 | 2 | 4 |
 | 0 | 1 | 3 | 5 |
 | 0 | 1 | 4 | 6 |
 | 0 | 2 | 5 | 7 |

*** clj--far more complicated; whence apply concat?
**** concat--doesn't make much sense by itself...
#+BEGIN_SRC clojure :results output
(println (concat '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7))))))
#+END_SRC

#+RESULTS:
: ((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7))))

**** process
***** basic example with pure lists--as expected from cl
#+BEGIN_SRC clojure
(de-nestc '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7)))))
#+END_SRC

#+RESULTS:
| 0 | 1 |   |   |
| 0 | 3 |   |   |
| 0 | 4 |   |   |
| 0 | 4 | 5 |   |
| 0 | 4 | 6 |   |
| 0 | 1 | 2 | 4 |
| 0 | 1 | 3 | 5 |
| 0 | 1 | 4 | 6 |
| 0 | 2 | 5 | 7 | 

***** basic example with lists of vectors--still as expected from cl
#+BEGIN_SRC clojure
(de-nestc '(([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
#+END_SRC  

#+RESULTS:
| 24 | 25 | 28 |
| 24 | 25 | 40 |
| 24 | 25 | 52 |
| 24 | 25 | 64 |
| 24 | 37 | 28 |
| 24 | 37 | 40 |
| 24 | 37 | 52 |
| 24 | 37 | 64 |
| 24 | 49 | 28 |
| 24 | 49 | 40 |
| 24 | 49 | 52 |
| 24 | 49 | 64 |
| 24 | 61 | 28 |
| 24 | 61 | 40 |
| 24 | 61 | 52 |
| 24 | 61 | 64 |
***** examining a data structure referred to by a var
#+BEGIN_SRC clojure :results output
(println (first trip014))
#+END_SRC

#+RESULTS:
: (([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64]))
***** huh? de-nest wraps a list around the
#+BEGIN_SRC clojure :results output
(println (de-nestc (first trip014)))
#+END_SRC

#+RESULTS:
: ((([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
***** ah. concat needs to be applied
#+BEGIN_SRC clojure :results output
(println (apply concat (first trip014)))
#+END_SRC

#+RESULTS:
: ([24 25 28] [24 25 40] [24 25 52] [24 25 64] [24 37 28] [24 37 40] [24 37 52] [24 37 64] [24 49 28] [24 49 40] [24 49 52] [24 49 64] [24 61 28] [24 61 40] [24 61 52] [24 61 64])

#+RESULTS:

#+BEGIN_SRC clojure
(de-nestc '(([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
#+END_SRC
*** clj--de-nestc code
#+BEGIN_SRC clojure :session cl-to-cloj
(defn de-nestc [x]
  (letfn [(denester [inner-x acc]
            (let [coll inner-x]
              (cond (empty? coll) acc
                    (not (counted? (first coll))) (cons coll acc)
                    :else (denester (first coll) (denester (rest coll) acc)))))]
    (denester x ())))



#+END_SRC

#+BEGIN_SRC clojure :results output
(println (apply concat (first trip014)))
#+END_SRC

#+RESULTS:
: ([24 25 28] [24 25 40] [24 25 52] [24 25 64] [24 37 28] [24 37 40] [24 37 52] [24 37 64] [24 49 28] [24 49 40] [24 49 52] [24 49 64] [24 61 28] [24 61 40] [24 61 52] [24 61 64])

* converting complex common lisp functions to clojure
** set-up pairs of pc-sets
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-up (pcset1 lst-of-pcsets)
  (cond ((null lst-of-pcsets) ())
	(t (cons pcset1 
		 (cons (car lst-of-pcsets) 
		       (set-up pcset1 (cdr lst-of-pcsets)))))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 4 |   |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 | 4 | 6 |
*** clj
backwards version because of cons-ing
#+BEGIN_SRC clojure
(defn set-up [pcset1 lst-of-pcsets]
  (loop [pc1 pcset1
         pcs lst-of-pcsets
         acc ()]
    (if (empty? pcs)
      acc
      (recur pc1 (rest pcs) (cons pc1 (cons (first pcs) acc))))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up((0 1 2) (0 1 2 4 6) (0 1 2) (0 4) (0 1 2) (0 1 2))


#+BEGIN_SRC clojure
(defn set-up [pcset1 lst-of-pcsets]
  (loop [pc1 pcset1
         pcs lst-of-pcsets
         acc ()]
    (if (empty? pcs)
    (reverse acc)
      (recur pc1 (rest pcs) (conj (conj acc (first pcs)) pc1)))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up((0 1 2) (0 1 2 4 6) (0 1 2) (0 4) (0 1 2) (0 1 2))

** make pairs = partition

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun make-pairs-from-list (lst)
  "turn a list of anythings into pairs of those things, simply
conjoining every two elements"
  (cond ((null lst) ())
	(t (cons (list (first lst) (second lst))
		 (make-pairs-from-list (nthcdr 2 lst))))))

(make-pairs-from-list '(0 1 2 3 4 5 6 7 8 9))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |
 | 2 | 3 |
 | 4 | 5 |
 | 6 | 7 |
 | 8 | 9 |

*** clj

#+BEGIN_SRC clojure
(partition 2 '(0 1 2 3 4 5 6 7 8 9))
#+END_SRC

#+RESULTS:
| 0 | 1 |
| 2 | 3 |
| 4 | 5 |
| 6 | 7 |
| 8 | 9 |
#+BEGIN_SRC clojure :session cl-to-cloj
(defn make-pairs-from-list [lst]
(partition 2 lst))

(make-pairs-from-list '(0 1 2 3 4 5 6 7 8 9))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/make-pairs-from-list((0 1) (2 3) (4 5) (6 7) (8 9))

** join up the first element from a given set with the rest of sets--jack-b
needs a better name!

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun jack-b (listA listA-prime)
  (cond ((null listA-prime) ())
	(t (cons 
	    (list (car listA)
		  (car listA-prime))
	    (jack-b listA (cdr listA-prime))))))

(jack-b '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
 #+END_SRC

 #+RESULTS:
 | 0 | (0 1)   |
 | 0 | (0 3)   |
 | 0 | (0 1 4) |
 | 0 | (0 1 5) |
 | 0 | (0 1)   |
 | 0 | (0 3)   |

*** clj

watch what happens when you switch up cons and conj here! Comedy ensues.

#+BEGIN_SRC clojure
(defn jack-b [lst1 lst2]
(loop [l1 lst1
       l2 lst2
       acc ()]
  (if (empty? l2) 
      acc
      (recur l1 (rest l2) (cons (list (first l1) (first l2)) acc)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/jack-b

f#+BEGIN_SRC clojure

(jack-b '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
| 0 | (0 3)   |
| 0 | (0 1)   |
| 0 | (0 1 5) |
| 0 | (0 1 4) |
| 0 | (0 3)   |
| 0 | (0 1)   |

** last1--a Graham utility

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun last1 (lst) (car (last lst)))

(last1 '((0 1)))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |

*** clj
#+BEGIN_SRC clojure
(last '((0 1)))
#+END_SRC

#+RESULTS:
| 0 | 1 |

** the ever important jack-rec--only called with make-pairs-from-lists?
*** cl
this guy does a particular kind of combinatoric setup that is
important for generating unique combinations of two chords.
That is, it will produce '((0 1) (0 2)) but not '((0 2) (0 1))

Gotta really reconsider what this is doing. Where is it in fact being
called? It looks like it might do a lot of work that might not be
necessary?? 

Or at least, the way it is being called in the final imset-code, as
quoted below, seems to be used to produce particular pairs that might
be produceable another way, esp. with clojure sequence functions.



 #+BEGIN_SRC lisp :session cl-to-cloj
(defun jack-rec (listA listA-prime)
      (cond ((null listA) ())
            (t (labels ((rec (an-x a-y)
                          (cond ((null listA) ())
                                (t (jack-b an-x a-y)))))
                 (list (rec listA listA-prime) (jack-rec (cdr listA) (cdr listA-prime)))))))


 #+END_SRC

#+BEGIN_SRC lisp :session cl-to-cloj
(jack-rec '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
| (0 (0 1))                                               | (0 (0 3)) | (0 (0 1 4)) | (0 (0 1 5)) | (0 (0 1)) | (0 (0 3)) |
| ((1 (0 3)) (1 (0 1 4)) (1 (0 1 5)) (1 (0 1)) (1 (0 3))) | NIL       |             |             |           |           |


This use of jack-rec would be almost perfectly duplicated by some
combinatorial function that did combinations WITH replacement.
#+BEGIN_SRC lisp :session cl-to-cloj
(make-pairs-from-list (de-nestc (jack-rec '((0 1) (0 2) (0 3)) '((0 1) (0 2) (0 3)))))
#+END_SRC

#+RESULTS:
| (0 1) | (0 1) |
| (0 1) | (0 2) |
| (0 1) | (0 3) |
| (0 2) | (0 2) |
| (0 2) | (0 3) |
| (0 3) | (0 3) |
| (NIL) | NIL   |

*** clj--jack-rec not necessary? 
If all jack-rec is required to do is participate in constructing pairs
of pairs, then...one must ask the question: is it possible to
construct those some other way?

#+BEGIN_SRC clojure
(defn jack-rec [lst1 lst2]
(letfn [(jackrec [inner-lst1 inner-lst2]
(cond (empty? l1) acc)))))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure
(jack-rec '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
*** clj--long process for producing combinations
#+BEGIN_SRC clojure
(defn help-make-pairs [[head & tail]]
(letfn [(rec [inner-tail]
          (cond (empty? inner-tail) ()
                :else (cons (list head (first inner-tail))
                            (rec (rest inner-tail)))))]
  (rec (concat (list head) tail))))


#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/help-make-pairs

#+BEGIN_SRC clojure
(help-make-pairs '(0 1 2 3 4))
#+END_SRC				   

#+RESULTS:
| 0 | 0 |
| 0 | 1 |
| 0 | 2 |
| 0 | 3 |
| 0 | 4 |

#+BEGIN_SRC clojure
(defn make-comb-pairs-from-flat-list [coll]
  (cond (empty? coll) ()
        :else (concat (help-make-pairs coll)
                      (make-comb-pairs-from-flat-list (rest coll)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/make-comb-pairs-from-flat-list

#+BEGIN_SRC clojure :results output
(println (make-comb-pairs-from-flat-list [0 1 2 3 4 5]))
#+END_SRC

#+RESULTS:
: ((0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (1 1) (1 2) (1 3) (1 4) (1 5) (2 2) (2 3) (2 4) (2 5) (3 3) (3 4) (3 5) (4 4) (4 5) (5 5))

** set-up-Tn-equivalent-Ys-with-X
*** cl
This bad-boy will eventually be dealing with massive state. Let's see
an example?

 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-up-Tn-equivalent-Ys-with-X (pcset1 pcset2)
  (set-up pcset1 (car (tni-all (list pcset2)))))
 #+END_SRC

 #+RESULTS:
 : SET-UP-TN-EQUIVALENT-YS-WITH-X

Produces pairs of set1 and transposed versions of set2
#+BEGIN_SRC lisp :session cl-to-cloj
(set-up-tn-equivalent-ys-with-x '(0 1) '(0 1 3))
#+END_SRC

#+RESULTS:
|  0 |  1 |    |
|  0 |  1 |  3 |
|  0 |  1 |    |
|  1 |  2 |  4 |
|  0 |  1 |    |
|  2 |  3 |  5 |
|  0 |  1 |    |
|  3 |  4 |  6 |
|  0 |  1 |    |
|  4 |  5 |  7 |
|  0 |  1 |    |
|  5 |  6 |  8 |
|  0 |  1 |    |
|  6 |  7 |  9 |
|  0 |  1 |    |
|  7 |  8 | 10 |
|  0 |  1 |    |
|  8 |  9 | 11 |
|  0 |  1 |    |
|  9 | 10 |  0 |
|  0 |  1 |    |
| 10 | 11 |  1 |
|  0 |  1 |    |
| 11 |  0 |  2 |

*** clj
**** clj prepare-set-up
#+BEGIN_SRC clojure :session cl-to-cloj
(defn prepare-set-up-tn-equivalent-Ys-with-x [pcset1 pcset2]
 (set-up pcset1 (first (TnI-all (list pcset2)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/prepare-set-up-tn-equivalent-Ys-with-x

**** clj-- produces wrong order!!!
(set-up-Tn-equivalent-Ys-with-X set1 set2)
#+BEGIN_SRC clojure :session cl-to-cloj
(defn set-up-Tn-equivalent-Ys-with-X [pcset1 pcset2]
(map reverse (partition 2 (prepare-set-up-tn-equivalent-Ys-with-x '(0 1) '(0 1 3)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up-Tn-equivalent-Ys-with-X

**** requirees two steps
#+BEGIN_SRC clojure :session cl-to-cloj
(map reverse (partition 2 (set-up-tn-equivalent-ys-with-x '(0 1) '(0 1 3))))
#+END_SRC

#+RESULTS:
| (0 1) | (0 1 3)   |
| (0 1) | (1 2 4)   |
| (0 1) | (2 3 5)   |
| (0 1) | (3 4 6)   |
| (0 1) | (4 5 7)   |
| (0 1) | (5 6 8)   |
| (0 1) | (6 7 9)   |
| (0 1) | (7 8 10)  |
| (0 1) | (8 9 11)  |
| (0 1) | (9 10 0)  |
| (0 1) | (10 11 1) |
| (0 1) | (11 0 2)  |
| (0 1) | (0 1 3)   |

Yikes! Reversing this corrects the order but transposes the wrong chord.
#+BEGIN_SRC clojure :session cl-to-cloj :results output
(println (set-up-tn-equivalent-ys-with-x  '(0 1 3) '(0 1)))
#+END_SRC

#+RESULTS:
: ((0 1) (0 1 3) (1 2) (0 1 3) (2 3) (0 1 3) (3 4) (0 1 3) (4 5) (0 1 3) (5 6) (0 1 3) (6 7) (0 1 3) (7 8) (0 1 3) (8 9) (0 1 3) (9 10) (0 1 3) (10 11) (0 1 3) (11 0) (0 1 3) (0 1) (0 1 3))

** pc-compari performs some pitch-class mod12 interval arithmetic
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun pc-compari (n1 n2)
  (cond ((<= n1 n2) (cond ((= n1 n2) 0)
			  (t (1+ (pc-compari n1 (1- n2))))))
	(t (cond ((= (mod n1 12) n2) 0)
		 (t (1+ (pc-compari (1+ n1) n2)))))))
 #+END_SRC

 #+RESULTS:
 : PC-COMPARI

#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 0 11)
#+END_SRC 

#+RESULTS:
: 11

#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 12 0)
#+END_SRC

#+RESULTS:
: 0
#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 11 0)
#+END_SRC

#+RESULTS:
: 1

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn pc-compari [n1 n2]
  (cond (<= n1 n2) (cond (= n1 n2) 0
                         :else (inc (pc-compari n1 (dec n2))))
        :else (cond (= (mod n1 12) n2) 0
                    :else (inc (pc-compari (inc n1) n2)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/pc-compari


#+BEGIN_SRC clojure :session cl-to-cloj
(pc-compari 0 12)
#+END_SRC

#+RESULTS:
: 12

#+BEGIN_SRC clojure :session cl-to-cloj
(pc-compari 11 0)
#+END_SRC

#+RESULTS:
: 1

** recursively do the pc-comparing

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun rec-do-pc-compari (lst1 lst2)
  (labels ((rec (x1 y1)
	     (cond ((null x1) ())
		   (t (cons (pc-compari (car x1) (car y1))
			    (rec (cdr x1) y1))))))
    (cond ((null lst2) ())
	  (t (cons (rec lst1 lst2)
		   (rec-do-pc-compari lst1 (cdr lst2)))))))
 #+END_SRC

 #+RESULTS:
 : REC-DO-PC-COMPARI

#+BEGIN_SRC lisp :session cl-to-cloj
(rec-do-pc-compari '(0 1 2) '(0 1 3))
#+END_SRC

#+RESULTS:
| 0 | 11 | 10 |
| 1 |  0 | 11 |
| 3 |  2 |  1 |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn rec-do-pc-compari [lst1 lst2]
  (letfn [(rec [l1 l2]
                   (cond (empty? l1) ()
                         :else (cons (pc-compari (first l1) (first l2))
                                     (rec (rest l1) l2))))]
    (cond (empty? lst2) ()
          :else (cons (rec lst1 lst2)
                      (rec-do-pc-compari lst1 (rest lst2))))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/rec-do-pc-compari
#+BEGIN_SRC clojure :session cl-to-cloj
(rec-do-pc-compari '(0 1 2) '(0 1 3))
#+END_SRC

#+RESULTS:
| 0 | 11 | 10 |
| 1 |  0 | 11 |
| 3 |  2 |  1 |

* wrap various functions from above
** createA-lewin-vector--called by IMSET-DECISION-MAKER
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun createA-lewin-vector (paired-set)
  (counting (flatten (rec-do-pc-compari (car paired-set) (cadr paired-set)))))
 #+END_SRC

 #+RESULTS:
 : CREATEA-LEWIN-VECTOR
#+BEGIN_SRC lisp :session cl-to-cloj
(createA-lewin-vector '((0 1) (0 2)))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
** [#B] create-lewin-vector--only called by functions never called
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-lewin-vector (set1 set2)
  (counting (flatten (rec-do-pc-compari set1 set2))))
 #+END_SRC

 #+RESULTS:
 : CREATE-LEWIN-VECTOR

#+BEGIN_SRC lisp :session cl-to-cloj
(create-lewin-vector '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

*** clj
 #+BEGIN_SRC clojure :session cl-to-cloj
(defn create-lewin-vector [set1 set2]
  (counting (flatten (rec-do-pc-compari set1 set2))))
 #+END_SRC

 #+RESULTS:
 : #'post_tonal_overtone.core/create-lewin-vector

#+BEGIN_SRC clojure :session cl-to-cloj
(create-lewin-vector '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

** [#B] create-straus-profile--only called by?
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-straus-profile (set1 set2)
  (clean-profile (create-lewin-vector set1 set2)))
 #+END_SRC

 #+RESULTS:
 : CREATE-STRAUS-PROFILE

*** clj



#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-straus-profile [set1 set2]
  (clean-profile (create-lewin-vector set1 set2)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-straus-profile [set1 set2]
  (sort (flatten (rec-do-pc-compari set1 set2))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/create-straus-profile

#+BEGIN_SRC clojure :session cl-to-cloj
(create-straus-profile '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 11 |

** [#B] create-12-straus-profiles--goes uncalled?

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12-straus-profiles (set1 set2)
  (let ((a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))))
    (labels ((rec (lst)
	       (create-straus-profile (first lst) (second lst))))
      (mapcar #'rec a))))
 #+END_SRC

 #+RESULTS:
 : CREATE-12-STRAUS-PROFILES

#+BEGIN_SRC lisp :session cl-to-cloj
(create-12-straus-profiles '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 0 | 1 |  2 | 11 |
| 0 | 1 |  2 |  3 |
| 1 | 2 |  3 |  4 |
| 2 | 3 |  4 |  5 |
| 3 | 4 |  5 |  6 |
| 4 | 5 |  6 |  7 |
| 5 | 6 |  7 |  8 |
| 6 | 7 |  8 |  9 |
| 7 | 8 |  9 | 10 |
| 8 | 9 | 10 | 11 |
| 0 | 9 | 10 | 11 |
| 0 | 1 | 10 | 11 |

*** clj--make-pairs-from list redunant
#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-12-straus-profiles [set1 set2]
  (let [a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))]
    (letfn [(rec [lst]
              (create-straus-profile (first lst) (second lst)))]
      (map rec a))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/create-12-straus-profiles

#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-12-straus-profiles [set1 set2]
  (let [a (set-up-Tn-equivalent-Ys-with-X set1 set2)]
    (letfn [(rec [lst]
              (create-straus-profile (first lst) (second lst)))]
      (map rec a))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/create-12-straus-profiles

#+BEGIN_SRC clojure :session cl-to-cloj
(create-12-straus-profiles '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 0 | 0 | 1 |  2 |  3 | 11 |
| 0 | 1 | 1 |  2 |  3 |  4 |
| 1 | 2 | 2 |  3 |  4 |  5 |
| 2 | 3 | 3 |  4 |  5 |  6 |
| 3 | 4 | 4 |  5 |  6 |  7 |
| 4 | 5 | 5 |  6 |  7 |  8 |
| 5 | 6 | 6 |  7 |  8 |  9 |
| 6 | 7 | 7 |  8 |  9 | 10 |
| 7 | 8 | 8 |  9 | 10 | 11 |
| 0 | 8 | 9 |  9 | 10 | 11 |
| 0 | 1 | 9 | 10 | 10 | 11 |
| 0 | 1 | 2 | 10 | 11 | 11 |
| 0 | 0 | 1 |  2 |  3 | 11 |

** [#B] create-12-lewin-vectors--goes uncalled?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12-lewin-vectors (set1 set2)
  (let ((a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))))
    (labels ((rec (lst)
	       (create-lewin-vector (first lst) (second lst))))
      (mapcar #'rec a))))
 #+END_SRC

 #+RESULTS:
 : CREATE-12-LEWIN-VECTORS

** [#B] create-24-lewin-vectors--goes uncalled?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-24-lewin-vectors (paired-list)
  (let* ((a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
	 (b (mapcar #'createA-lewin-vector a))
	 (c (mapcar #'reverse b)))
    (append b c)))
 #+END_SRC

** [#B] create-Astraus-profile--called only by create-12A, which goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-Astraus-profile (paired-list)
  (clean-profile (createA-lewin-vector paired-list)))
 #+END_SRC

** [#B] create-12A-straus-profiles
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12A-straus-profiles (paired-list)
  (let ((a (make-pairs-from-list 
	    (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					    (cadr paired-list)))))
    (mapcar #'create-Astraus-profile a)))
 #+END_SRC

* set searching
** looking--is called by comparing
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun looking (mset)
  (cond ((null mset) ())
	(t (cons (count (car mset) mset)
		 (looking (cdr mset))))))
 #+END_SRC

 #+RESULTS:
 : LOOKING
#+BEGIN_SRC lisp :session cl-to-cloj
(mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |

#+BEGIN_SRC lisp :session cl-to-cloj
(reverse (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2)))))
#+END_SRC

#+RESULTS:
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

#+BEGIN_SRC lisp :session cl-to-cloj
(append (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))))
	(reverse (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2)))))
)
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
#+BEGIN_SRC lisp :session cl-to-cloj
(mapcar #'clean-profile (append (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))))
	   (reverse (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2)))))
	   ))
#+END_SRC

#+RESULTS:
| 0 | 1 |  2 | 11 |
| 0 | 1 |  2 |  3 |
| 1 | 2 |  3 |  4 |
| 2 | 3 |  4 |  5 |
| 3 | 4 |  5 |  6 |
| 4 | 5 |  6 |  7 |
| 5 | 6 |  7 |  8 |
| 6 | 7 |  8 |  9 |
| 7 | 8 |  9 | 10 |
| 8 | 9 | 10 | 11 |
| 0 | 9 | 10 | 11 |
| 0 | 1 | 10 | 11 |
| 0 | 1 | 10 | 11 |
| 0 | 9 | 10 | 11 |
| 8 | 9 | 10 | 11 |
| 7 | 8 |  9 | 10 |
| 6 | 7 |  8 |  9 |
| 5 | 6 |  7 |  8 |
| 4 | 5 |  6 |  7 |
| 3 | 4 |  5 |  6 |
| 2 | 3 |  4 |  5 |
| 1 | 2 |  3 |  4 |
| 0 | 1 |  2 |  3 |
| 0 | 1 |  2 | 11 |

** comparing--is called by locating
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun comparing (mset-list)
  (let ((canon (mapcar #'list-to-integer (mapcar #'looking mset-list))))
    (list (apply #'max canon) canon)))
 #+END_SRC

** locating--only called once. deals with an edge case
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun locating (mset-list)
  (let ((chart (comparing mset-list)))
    (nth (1- (cadr (locate (car chart) (cadr chart)))) mset-list)))
 #+END_SRC

** locate--called once prominently, a kind of database lookup

*** 
*** cl--finds the occurrence of a value at a certain place in a list

why does this return the value that was searched for as well as the
location? Some peculiarity of where it is called?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun locate (x lat)
  (let ((newlat (reverse lat)))
    (labels
	((rec (rec-x rec-lat)
	   (cond ((null rec-lat) ())
		 ((equal rec-x (car rec-lat)) 
		  (cons (length rec-lat) (rec rec-x (cdr rec-lat))))
		 (t (rec rec-x (cdr rec-lat))))))
      (cons x (reverse (rec x newlat))))))
 #+END_SRC

 #+RESULTS:
 : LOCATE

#+BEGIN_SRC lisp :session cl-to-cloj
(locate 10 '(0 100 10 1000 10 100000))
#+END_SRC

#+RESULTS:
| 10 | 3 | 5 |
*** clj--can use keep-indexed
taken from SO discussions about indices and finding
http://stackoverflow.com/questions/4830900/how-do-i-find-the-index-of-an-item-in-a-vector
http://stackoverflow.com/questions/8641305/find-index-of-an-element-matching-a-predicate-in-clojure

#+BEGIN_SRC clojure :session cl-to-cloj
(defn positions
  [pred coll]
  (keep-indexed (fn [idx x]
                  (when (pred x)
                    idx))
                coll))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/positions

#+BEGIN_SRC clojure :session cl-to-cloj
(positions #(= % 10) '(0 100 10 1000 10 100000))
#+END_SRC

#+RESULTS:
| 2 | 4 |

* prime-form utilities
** rotate
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun rotate (list count)
  (if (minusp count)
      (rotate list (+ (length list) count))
      (nconc (subseq list count) (subseq list 0 count))))
 #+END_SRC

 #+RESULTS:
 : ROTATE

#+BEGIN_SRC lisp :session cl-to-cloj
(rotate '(0 1 2 11) 1)
#+END_SRC

#+RESULTS:
| 1 | 2 | 11 | 0 |

#+BEGIN_SRC lisp :session cl-to-cloj
(rotate '(0 1 2 11) 2)

#+END_SRC

#+RESULTS:
| 2 | 11 | 0 | 1 |

1. rotate
2. my-rotate
3. all-rotations
4. wrap-vectors--uncalled
   1. find-prime-form
   2. forte-decision
   3. forte-primeA
   4. multiset-forte-primeA
   5. imset-decision-maker

#+BEGIN_SRC lisp :session cl-to-cloj

#+END_SRC
** my-rotate
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun my-rotate (lst)
  (let ((n (length lst)))
    (labels 
	((rec (rec-lst rec-n)
	   (if (zerop rec-n) ()
	       (list (rotate rec-lst rec-n)
		     (rec rec-lst (1- rec-n))))))
      (rec lst n))))
 #+END_SRC

 #+RESULTS:
 : MY-ROTATE

#+BEGIN_SRC lisp :session cl-to-cloj
(my-rotate '(0 1 2 11))
#+END_SRC

#+RESULTS:
|          0 |                             1 | 2 | 11 |
| (11 0 1 2) | ((2 11 0 1) ((1 2 11 0) NIL)) |   |    |

** all-rotations
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun all-rotations (lst)
  (butlast (de-nestC (my-rotate lst))))
 #+END_SRC

 #+RESULTS:
 : ALL-ROTATIONS

#+BEGIN_SRC lisp :session cl-to-cloj
(all-rotations '(0 1 2 11))

#+END_SRC

#+RESULTS:
|  0 |  1 |  2 | 11 |
| 11 |  0 |  1 |  2 |
|  2 | 11 |  0 |  1 |
|  1 |  2 | 11 |  0 |

** mod12math--replicates other mod12 arithmetic??
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12math (less more)
  (cond ((<= less more) (- more less))
	(t (- (+ 12 more) less))))
 #+END_SRC

 #+RESULTS:
 : MOD12MATH

#+BEGIN_SRC lisp :session cl-to-cloj
(mod12math 0 1)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC lisp :session cl-to-cloj
(mod12math 11 2)
#+END_SRC

#+RESULTS:
: 3

** primer
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun primer (ordered-set)
  (cond ((null ordered-set) ())
	(t (cons (mod12math (car ordered-set) (last1 ordered-set))
		 (primer (butlast ordered-set))))))
 #+END_SRC

 #+RESULTS:
 : PRIMER

#+BEGIN_SRC lisp :session cl-to-cloj
(primer '(11 0 1 2))
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 | 0 |

** prime-vector
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun prime-vector (ordered-set)
  (let ((basic-vector (primer ordered-set)))
    (cons (car basic-vector) (butlast (reverse (butlast basic-vector))))))
 #+END_SRC

 #+RESULTS:
 : PRIME-VECTOR

#+BEGIN_SRC lisp :session cl-to-cloj
(prime-vector '(11 0 1 2))
#+END_SRC

#+RESULTS:
| 3 | 1 | 2 |

** list-to-integer
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun list-to-integer (lst-of-ints)
  (let ((high-exp (length lst-of-ints)))
    (labels 
	((rec (lst place)
	   (cond ((null lst) 0)
		 (t (+ (* (car lst) (expt 10 place))
		       (rec (cdr lst) (1- place)))))))
      (rec lst-of-ints high-exp))))
 #+END_SRC

 #+RESULTS:
 : LIST-TO-INTEGER

#+BEGIN_SRC lisp :session cl-to-cloj

#+END_SRC
** find-prime-form-from-list
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun find-prime-form-from-list (ordered-pcset)
  (let* ((a (all-rotations ordered-pcset))
	 (b (mapcar #'prime-vector a))
	 (c (mapcar #'list-to-integer b)))
    (nth (position (apply #'min c) c) a)))
 #+END_SRC

 #+RESULTS:
 : FIND-PRIME-FORM-FROM-LIST

** set-to-zero--called by forte decision
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-to-zero (ordered-pcset)
  (let ((n (car ordered-pcset)))
    (mapcar #'(lambda (x) 
		(cond ((>= x n) (- x n))
		      (t (- (+ 12 x) n))))
	    ordered-pcset)))
 #+END_SRC

 #+RESULTS:
 : SET-TO-ZERO

** invert-mod12-pcset--called by forte-decision
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun invert-mod12-pcset (pcset)
 (sort (mapcan #'mod12 (list (mapcar #'(lambda (x) (- 12 x)) pcset))) #'<))
 #+END_SRC

 #+RESULTS:
 : INVERT-MOD12-PCSET

** forte-decision--called by forte primeA
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-decision (pcset)
  (let ((a (set-to-zero (find-prime-form-from-list pcset))))
    (list a (set-to-zero (find-prime-form-from-list (invert-mod12-pcset a))))))
 #+END_SRC

 #+RESULTS:
 : FORTE-DECISION

** another-forte--called by forte primeA
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun another-forte (setx sety)
  (let ((a setx) (b sety))
    (labels ((rec (set1 set2)
	       (cond ((null set1) setx)
		     ((> (car set1) (car set2)) sety)
		     ((< (car set1) (car set2)) setx)
		     (t (rec (cdr set1) (cdr set2))))))
      (rec a b))))
 #+END_SRC

 #+RESULTS:
 : ANOTHER-FORTE


 ;; (defun 24create (paired-list)
 ;;   (let* ((a (make-pairs-from-list 
 ;; 	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
 ;; 					     (cadr paired-list))))
 ;; 	 (b (mapcar #'createA-lewin-vector a))
 ;; 	 (c (mapcar #'reverse b))
 ;; 	 (d (append b c))
 ;; 	 (e (mapcar #'clean-profile d)) ; effectively creates a straus-profile
 ;; 	 (f (mapcar #'multiset-forte-prime e))
 ;; 	 (g (mapcar #'multiset-forte-decision e)))
 ;;     (mapcar #'list d e f g)))

 ;; simply remove duplicates you say, eh? how would you reintroduce
 ;; them? quote unquote.

** forte-primeA--called by multiset-forte-primeA
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-primeA (pcset)
  (let ((a (forte-decision pcset)))
    (another-forte (car a) (cadr a))))
 #+END_SRC

 #+RESULTS:
 : FORTE-PRIMEA

** multiset-forte-primeA--called once by IMSET-DECISION-MAKER; used as a "database"
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-primeA (mset)
 (forte-primeA (remove-duplicates mset)))
 #+END_SRC

 #+RESULTS:
 : MULTISET-FORTE-PRIMEA

** [#B] wrap-vectors--never called
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun wrap-vectors (ordered-set)
  (mapcar #'prime-vector (all-rotations ordered-set)))
 #+END_SRC

 #+RESULTS:
 : WRAP-VECTORS

#+BEGIN_SRC lisp :session cl-to-cloj
(wra
#+END_SRC

** [#B] Ainvert-mod12-pcset--called only by a never-called function 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun Ainvert-mod12-pcset (pcset)
 (mapcan #'mod12 (list (mapcar #'(lambda (x) (- 12 x)) pcset))))
 #+END_SRC

 #+RESULTS:
 : AINVERT-MOD12-PCSET

** [#B] find-set-inversion--never called
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun find-set-inversion (pcset)
  (set-to-zero (reverse (Ainvert-mod12-pcset pcset))))
 #+END_SRC

 #+RESULTS:
 : FIND-SET-INVERSION

** [#B] forte-prime--only called by multiset-forte-prime, which goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-prime (pcset)
  (let ((a (forte-decision pcset)))
    (if (every #'<= (car a) (cadr a))
	(car a)
	(cadr a))))
 #+END_SRC

** [#B] multiset-forte-prime--goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-prime (mset)
 (forte-prime (remove-duplicates mset)))
 #+END_SRC

** [#B] multiset-forte-decision--goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-decision (mset)
  (forte-decision (remove-duplicates mset)))
 #+END_SRC

 #+RESULTS:
 : MULTISET-FORTE-DECISION

* full documentation separated out for imset-decision-maker
** streamlined documentation
#+BEGIN_SRC lisp :session cl-to-cloj
(defun imset-decision-maker (paired-list)
  (let* (
	 (a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
	 (b (mapcar #'createA-lewin-vector a))
	 (c (mapcar #'reverse b))
	 (d (append b c))
	 (e (mapcar #'clean-profile d)) ; turns out CLEAN-PROFILE effectively creates a Straus-profile
	 (f (multiset-forte-primeA (car e))) ; car because only need check the first one as they
					; all will represent the same forteprime (why, again?)
	 (g (mapcar #'remove-duplicates e))
	 (h (locate f g))
	 (i (loop for idx in (cdr h) ; must use cdr portion of LOCATE output
	       collect (nth (1- idx) e))) ;locate is not zero-indexed apparently
	 (j (remove-duplicates i :test #'equal)))
    (if (<= (length j) 2)
	(if (every #'<= (car j) (cadr j))
	    (car j)
	    (cadr j))
	(locating j))))
#+END_SRC

** broken up documentation
#+BEGIN_SRC lisp :session cl-to-cloj
	 ;; a is the "home-list", the foundation, providing all the
	 ;; paired sets across the transpositional spectrum for a given
	 ;; X-Y pair
	 (a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
#+BEGIN_SRC lisp :session cl-to-cloj
;; determine the IFUNC of each X-Y pair in A, where the X chord is 
	 ;; constant and Y is transposed by Tn for n from 0 to 11
	 (b (mapcar #'createA-lewin-vector a))
#+END_SRC
#+BEGIN_SRC lisp :session cl-to-cloj	 
	 ;; also determine the INVERSE of each IFUNC simply
	 ;; at one time by reversing the lewin-vector
	 ;;
	 ;; disadvantage is that you don't get the generating pair
	 ;; explicitly, but still a neat trick on Lewin-style vectors


	 (c (mapcar #'reverse b))
#+END_SRC

#+BEGIN_SRC lisp :session cl-to-cloj
;; make one big list that contains all these
	 ;; lewin-vectors. we will then use this list of 24 IFUNCS in
	 ;; Lewin form to find the preferred prime-form according to the 
	 ;; prime-form algorithm of choice

	 (d (append b c))
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; create the analogous 24 straus-profiles
	 (e (mapcar #'clean-profile d)) ; turns out CLEAN-PROFILE effectively creates a Straus-profile
#+END_SRC
	 

#+BEGIN_SRC lisp :session cl-to-cloj
;; determine the forte prime form that the reduced
	 ;; straus multisets represent
	 ;; 
	 ;; could be replaced with Straus-Rahn algorithm if desired
	 (f (multiset-forte-primeA (car e))) ; car because only need check the first one as they
					     ; all will represent the
	 ;; same forteprime (why, again?)
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; make all imsets into sets in order to perform
	 ;; some nifty LOCATE-ing maneuvers

	 (g (mapcar #'remove-duplicates e))
#+END_SRC
	 

#+BEGIN_SRC lisp :session cl-to-cloj
;; find the location(s) of the forte prime in this 
	 ;; new list of sets
	 ;;
	 ;; NB. F is a shallow list, and contains the only the single prime-form
	 (h (locate f g))
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; IMPORTANT: use the location of 
	 ;; prime-form f in the list of sets g
	 ;; to find the generating multiset parent(s) in e
	 ;; possible that there is MORE THAN ONE!
	 (i (loop for idx in (cdr h) ; must use cdr portion of LOCATE output
	       collect (nth (1- idx) e))) ;locate is not zero-indexed apparently
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; leave only unique representatives generators of the
	 ;; forte-prime form. at max there should be two 
	 ;;
	 ;; NOT NECESSARILY!!! see ((0 2 4) (0 2 6)) 
	 (j (remove-duplicates i :test #'equal))
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
    ;; following code commented out because it failed to 
    ;; detect the prime form in the specific tricky case 
    ;; mentioned just above. otherwise, a hack worth
    ;; looking at, at least for its use of EVERY
    ;;
    ;; (if (every #'<= (car j) (cadr j))
    ;; 	(list 'first j)
    ;; 	(list 'second j))
    ;;
	 ;;; this alone just cannot do it.
	 ;;; there must be a larger function for looking 
	 ;;; within multiset families--update: that is now
	 ;;; done by the function, LOCATING below
#+END_SRC

#+BEGIN_SRC lisp :session cl-to-cloj
    ;; do pairwise comparisons to find the imset that 
    ;; most consistently is lower from left to right
    ;; and use LOCATING in the special case
    ;;
    ;; in compilation this won't print but use for seeing
    ;; step by step the process here
    ;;
    ;; (format t "~{~{~a ~%~}~%~}" (list a d e f g h i j))

(if (<= (length j) 2)
	(if (every #'<= (car j) (cadr j))
	    (car j)
	    (cadr j))
	(locating j))
#+END_SRC



** locate is uncalled??
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun map-locate (loli)
  (let ((full-list loli))
   (labels ((hmm (rec-loli)
	      (cond ((null rec-loli) ())
		    (t (cons (locate (car rec-loli) full-list)
			     (hmm (cdr rec-loli)))))))
     (hmm loli))))
 #+END_SRC

** massive full unexpurgated function composition--up to comparing length of results

#+BEGIN_SRC lisp :session cl-to-cloj
(length
 (remove-duplicates
  (loop for idx in
       (cdr (locate
	     (multiset-forte-primeA
	      (car (mapcar #'clean-profile
			   (append
			    (mapcar #'createA-lewin-vector
				    (make-pairs-from-list 
				     (set-up-Tn-equivalent-Ys-with-X '(0 1) 
								     '(0 2))))
			    (mapcar #'reverse
				    (mapcar #'createA-lewin-vector
					    (make-pairs-from-list 
					     (set-up-Tn-equivalent-Ys-with-X '(0 1) 
									     '(0 2)))))))))
	     (mapcar #'remove-duplicates
		     (mapcar #'clean-profile
			     (append  (mapcar #'createA-lewin-vector
					      (make-pairs-from-list 
					       (set-up-Tn-equivalent-Ys-with-X '(0 1) 
									       '(0 2))))
				      (mapcar #'reverse
					      (mapcar #'createA-lewin-vector
						      (make-pairs-from-list 
						       (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										       '(0 2))))))))))
     collect (nth (1- idx)
		  (mapcar #'clean-profile
			  (append  (mapcar #'createA-lewin-vector
					   (make-pairs-from-list 
					    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
									    '(0 2))))
				   (mapcar #'reverse
					   (mapcar #'createA-lewin-vector
						   (make-pairs-from-list 
						    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										    '(0 2)))))))) ) :test #'equal))
;; 1

(remove-duplicates (loop for idx in (cdr (locate (multiset-forte-primeA (car (mapcar #'clean-profile
										     (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
															      (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																			      '(0 2))))
											      (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
																		(set-up-Tn-equivalent-Ys-with-X '(0 1) 
																						'(0 2)))))))))
						 (mapcar #'remove-duplicates
							 (mapcar #'clean-profile
								 (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
													  (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																	  '(0 2))))
									  (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
															    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																			    '(0 2))))))))))
		      collect (nth (1- idx) (mapcar #'clean-profile
						    (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
											     (set-up-Tn-equivalent-Ys-with-X '(0 1) 
															     '(0 2))))
							     (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
													       (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																	       '(0 2)))))))) ) :test #'equal)

;; ((0 1 2 3))

(loop for idx in (cdr (locate (multiset-forte-primeA (car (mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))))
	(mapcar #'remove-duplicates
	(mapcar #'clean-profile
		(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
							 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
											 '(0 2))))
			 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
									   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													   '(0 2))))))))))
   collect (nth (1- idx) (mapcar #'clean-profile
				 (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
									  (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													  '(0 2))))
					  (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
											    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
															    '(0 2)))))))) )

;; ((0 1 2 3) (0 1 2 3))

(locate (multiset-forte-primeA (car (mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))))
	(mapcar #'remove-duplicates
	(mapcar #'clean-profile
		(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
							 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
											 '(0 2))))
			 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
									   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													   '(0 2)))))))))

;; ((0 1 2 3) 2 22)

(mapcar #'remove-duplicates
	(mapcar #'clean-profile
		(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
							 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
											 '(0 2))))
			 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
									   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													   '(0 2))))))))

;; ((0 1 2 11) (0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (4 5 6 7) (5 6 7 8) (6 7 8 9) (7 8 9 10) (8 9 10 11) (0 9 10 11) (0 1 10 11) (0 9 10 11) (8 9 10 11) (7 8 9 10) (6 7 8 9) (5 6 7 8) (4 5 6 7) (3 4 5 6) (2 3 4 5) (1 2 3 4) (0 1 2 3) (0 1 2 11) (0 1 10 11))

(multiset-forte-primeA (car (mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))))

;; (0 1 2 3)

(mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))
;; ((0 1 2 11) (0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (4 5 6 7) (5 6 7 8) (6 7 8 9) (7 8 9 10) (8 9 10 11) (0 9 10 11) (0 1 10 11) (0 9 10 11) (8 9 10 11) (7 8 9 10) (6 7 8 9) (5 6 7 8) (4 5 6 7) (3 4 5 6) (2 3 4 5) (1 2 3 4) (0 1 2 3) (0 1 2 11) (0 1 10 11))

(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2))))
	 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2))))))
;;((1 1 1 0 0 0 0 0 0 0 0 1) (1 1 1 1 0 0 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 0 0 1 1 1 1) (1 0 0 0 0 0 0 0 0 1 1 1) (1 1 0 0 0 0 0 0 0 0 1 1) (1 0 0 0 0 0 0 0 0 1 1 1) (0 0 0 0 0 0 0 0 1 1 1 1) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (1 1 1 1 0 0 0 0 0 0 0 0) (1 1 1 0 0 0 0 0 0 0 0 1) (1 1 0 0 0 0 0 0 0 0 1 1))

(mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2)))))

;;((1 0 0 0 0 0 0 0 0 1 1 1) (0 0 0 0 0 0 0 0 1 1 1 1) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (1 1 1 1 0 0 0 0 0 0 0 0) (1 1 1 0 0 0 0 0 0 0 0 1) (1 1 0 0 0 0 0 0 0 0 1 1))

(mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2))))

;;((1 1 1 0 0 0 0 0 0 0 0 1) (1 1 1 1 0 0 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 0 0 1 1 1 1) (1 0 0 0 0 0 0 0 0 1 1 1) (1 1 0 0 0 0 0 0 0 0 1 1))

(make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2)))

;;(((0 1) (0 2)) ((0 1) (1 3)) ((0 1) (2 4)) ((0 1) (3 5)) ((0 1) (4 6)) ((0 1) (5 7)) ((0 1) (6 8)) ((0 1) (7 9)) ((0 1) (8 10)) ((0 1) (9 11)) ((0 1) (10 0)) ((0 1) (11 1)))

(set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))
;; ((0 1) (0 2) (0 1) (1 3) (0 1) (2 4) (0 1) (3 5) (0 1) (4 6) (0 1) (5 7) (0 1) (6 8) (0 1) (7 9) (0 1) (8 10) (0 1) (9 11) (0 1) (10 0) (0 1) (11 1))



#+END_SRC
