* converting basic common lisp functions to clojure
** basic "list adder" function
*** common lisp
#+BEGIN_SRC lisp :session cl-to-cloj
(defun list+ (n lst)
  (mapcar #'(lambda (x) (+ n x)) lst))

(list+ 12 '(0 4 7))
#+END_SRC

#+RESULTS:
| 12 | 16 | 19 |

*** clojure
#+BEGIN_SRC clojure :session cl-to-cloj
(defn list+ [n lst]
  (map (fn [x] (+ n x)) lst))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/list+

#+BEGIN_SRC clojure :session cl-to-cloj
(list+ 3 [1 2 3])
#+END_SRC

#+RESULTS:
| 4 | 5 | 6 |
** generate 12 transposition of a given set
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun Tn1-11 (n pcset)     ;expects an argument of n=12
    (cond ((= n -1) ())
	  (t (cons (list+ n pcset)
		   (Tn1-11 (- n 1) pcset)))))

(Tn1-11 12 '(0 4 7))
 #+END_SRC

 #+RESULTS:
 | 12 | 16 | 19 |
 | 11 | 15 | 18 |
 | 10 | 14 | 17 |
 |  9 | 13 | 16 |
 |  8 | 12 | 15 |
 |  7 | 11 | 14 |
 |  6 | 10 | 13 |
 |  5 |  9 | 12 |
 |  4 |  8 | 11 |
 |  3 |  7 | 10 |
 |  2 |  6 |  9 |
 |  1 |  5 |  8 |
 |  0 |  4 |  7 |
*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn Tn1-11 [pcset]
  (loop [n 12
         acc ()
         ]
    (if (< n 0)
      acc
      (recur (dec n) (conj acc (list+ n pcset))))))


#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/Tn1-11

#+BEGIN_SRC clojure :session cl-to-cloj
(Tn1-11 '(0 4 7))
#+END_SRC

#+RESULTS:
|  0 |  4 |  7 |
|  1 |  5 |  8 |
|  2 |  6 |  9 |
|  3 |  7 | 10 |
|  4 |  8 | 11 |
|  5 |  9 | 12 |
|  6 | 10 | 13 |
|  7 | 11 | 14 |
|  8 | 12 | 15 |
|  9 | 13 | 16 |
| 10 | 14 | 17 |
| 11 | 15 | 18 |
| 12 | 16 | 19 |

** mod12 across a list
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12 (lst)
  (mapcar #'(lambda (x) (mod x 12)) lst))

(mod12 '(24 28 31))
 #+END_SRC

 #+RESULTS:
 | 0 | 4 | 7 |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn mod12 [lst]
(map #(mod % 12) lst))

(mod12 [24 28 31])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/mod12(0 4 7)

** mod12 across nested lists

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12-all (lst-of-lsts)
  (mapcar #'mod12 lst-of-lsts))

(mod12-all '((24 28 31) (36 40 43)))
 #+END_SRC

 #+RESULTS:
 | 0 | 4 | 7 |
 | 0 | 4 | 7 |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn mod12-all [lst-of-lsts]
(map mod12 lst-of-lsts))

(mod12-all [[24 28 31] [36 40 43]])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/mod12-all((0 4 7) (0 4 7))

** generate transposed lists from list of prime form pcset

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun TnI-all (lol-of-pcsets)
 (mapcar #'(lambda (x) (reverse (mod12-all (Tn1-11 11 x)))) lol-of-pcsets))

(TnI-all '((0 1 2) (0 3 6)))
 #+END_SRC

 #+RESULTS:
 | (0 1 2) | (1 2 3) | (2 3 4) | (3 4 5) | (4 5 6)  | (5 6 7)  | (6 7 8) | (7 8 9)  | (8 9 10) | (9 10 11) | (10 11 0) | (11 0 1) |
 | (0 3 6) | (1 4 7) | (2 5 8) | (3 6 9) | (4 7 10) | (5 8 11) | (6 9 0) | (7 10 1) | (8 11 2) | (9 0 3)   | (10 1 4)  | (11 2 5) |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn TnI-all [lol-of-pcsets]
(map #(mod12-all (Tn1-11 %)) lol-of-pcsets))

(TnI-all [[0 1 2] [0 4 7]])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/TnI-all(((0 1 2) (1 2 3) (2 3 4) (3 4 5) (4 5 6) (5 6 7) (6 7 8) (7 8 9) (8 9 10) (9 10 11) (10 11 0) (11 0 1) (0 1 2)) ((0 4 7) (1 5 8) (2 6 9) (3 7 10) (4 8 11) (5 9 0) (6 10 1) (7 11 2) (8 0 3) (9 1 4) (10 2 5) (11 3 6) (0 4 7)))

** flatten already in clojure.core
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun flatten (x)
  (labels 
      ((rec (x acc) 
	 (cond ((null x) acc) 
	       ((atom x) (cons x acc)) 
	       (t (rec (car x) (rec (cdr x) acc))))))
    (rec x nil)))
 #+END_SRC

 #+RESULTS:
 : FLATTEN


 ;; (defun count-occurrences (vector-list)
 ;;   (cond ((null vector-list) ())
 ;; ;; expects only the 12 pitch classes
 ;; 	(t (list (count 0 vector-list)
 ;; 		 (count 1 vector-list)
 ;; 		 (count 2 vector-list)
 ;; 		 (count 3 vector-list)
 ;; 		 (count 4 vector-list)
 ;; 		 (count 5 vector-list)
 ;; 		 (count 6 vector-list)
 ;; 		 (count 7 vector-list)
 ;; 		 (count 8 vector-list)
 ;; 		 (count 9 vector-list)
 ;; 		 (count 10 vector-list)
 ;; 		 (count 11 vector-list)))))

 ;; this is an exhaustive version of COUNT that is also
 ;; recursive. why does it need to use LABELS? so you don't
 ;; have to explicitly pass in '11', or so you can call 
 ;; REVERSE at the end? Probably possible to write it more simply.

** counting? counts occurrences of elements--interval vector func
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun counting (lst-of-12ints)
  "Use COUNT to find the number of occurrences of each
 member of the list"
  (labels ((count-up (n ints)
	     (cond ((< n 0) ())
		   (t (cons (count n ints)
			    (count-up (1- n) ints))))))
    ;; assumes you want to be looking at the twelve pitch-classes
    (reverse (count-up 11 lst-of-12ints))))


(counting '(3 1 2 0 2 4 0 0 0 0 0 0))
 #+END_SRC

 #+RESULTS:
 | 7 | 1 | 2 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |


#+BEGIN_SRC lisp :session cl-to-cloj
(count 12 '(12 0 1 2 12))
#+END_SRC

#+RESULTS:
: 2

*** clj--frequencies produces a map??
#+BEGIN_SRC clojure :session cl-to-cloj :results output
(println (frequencies [3 1 2 0 2 4 0 0 0 0 0 0]))
#+END_SRC

#+RESULTS:
: {3 1, 1 1, 2 2, 0 7, 4 1}

** repeat elements
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun repeating (num-element1 num-element2)
  (cond ((= 0 num-element1) ())
	(t (cons num-element2
		 (repeating (- num-element1 1) num-element2)))))

(repeating 4 6)
 #+END_SRC

 #+RESULTS:
 | 6 | 6 | 6 | 6 |

*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(repeat 4 6)
#+END_SRC

#+RESULTS:
| 6 | 6 | 6 | 6 |

** frequencies vs. fixed array?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun 12-profile (vector)
  (list (repeating (nth 0 vector) 0)
	(repeating (nth 1 vector) 1)
	(repeating (nth 2 vector) 2)
	(repeating (nth 3 vector) 3)
	(repeating (nth 4 vector) 4)
	(repeating (nth 5 vector) 5)
	(repeating (nth 6 vector) 6)
	(repeating (nth 7 vector) 7)
	(repeating (nth 8 vector) 8)
	(repeating (nth 9 vector) 9)
	(repeating (nth 10 vector) 10)
	(repeating (nth 11 vector) 11)))

(12-profile (counting '(3 1 2 0 2 4 0 0 0 0 0 0)))
 #+END_SRC

 #+RESULTS:
 | (0 0 0 0 0 0 0) | (1) | (2 2) | (3) | (4) | NIL | NIL | NIL | NIL | NIL | NIL | NIL |

** "clean profile" flattens and removes

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun clean-profile (single-vector)
  (flatten (remove-if #'null (12-profile single-vector))))

(clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11))

 #+END_SRC

 #+RESULTS:
 | 1 | 2 | 3 | 3 | 4 | 4 | 4 | 5 | 5 | 5 | 6 | 6 | 6 | 7 | 7 | 7 | 7 | 7 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 |

*** clj?

** de-nesting to one level
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun de-nestC (x)
  (labels ((rec (x acc)
	     (cond ((null x) acc)
		   ((atom (car x)) (cons x acc)) 
		   (t (rec (car x) (rec (cdr x) acc)))))) 
    (rec x nil)))

(de-nestC '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7)))))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |   |   |
 | 0 | 3 |   |   |
 | 0 | 4 |   |   |
 | 0 | 4 | 5 |   |
 | 0 | 4 | 6 |   |
 | 0 | 1 | 2 | 4 |
 | 0 | 1 | 3 | 5 |
 | 0 | 1 | 4 | 6 |
 | 0 | 2 | 5 | 7 |

*** clj--far more complicated process!
**** concat--doesn't make much sense by itself...
#+BEGIN_SRC clojure :results output
(println (concat '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7))))))
#+END_SRC

#+RESULTS:
: ((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7))))

**** understanding recursive clojure definition
***** de-nestc code
#+BEGIN_SRC clojure :session cl-to-cloj
(defn de-nestc [x]
  (letfn [(denester [inner-x acc]
            (let [coll inner-x]
              (cond (empty? coll) acc
                    (not (counted? (first coll))) (cons coll acc)
                    :else (denester (first coll) (denester (rest coll) acc)))))]
    (denester x ())))



#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/de-nestc((0 1) (0 3) (0 4) (0 4 5) (0 4 6) (0 1 2 4) (0 1 3 5) (0 1 4 6) (0 2 5 7))

***** basic example with pure lists--as expected from cl
#+BEGIN_SRC clojure
(de-nestc '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7)))))
#+END_SRC

#+RESULTS:
| 0 | 1 |   |   |
| 0 | 3 |   |   |
| 0 | 4 |   |   |
| 0 | 4 | 5 |   |
| 0 | 4 | 6 |   |
| 0 | 1 | 2 | 4 |
| 0 | 1 | 3 | 5 |
| 0 | 1 | 4 | 6 |
| 0 | 2 | 5 | 7 | 

***** basic example with lists of vectors--still as expected from cl
#+BEGIN_SRC clojure
(de-nestc '(([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
#+END_SRC  

#+RESULTS:
| 24 | 25 | 28 |
| 24 | 25 | 40 |
| 24 | 25 | 52 |
| 24 | 25 | 64 |
| 24 | 37 | 28 |
| 24 | 37 | 40 |
| 24 | 37 | 52 |
| 24 | 37 | 64 |
| 24 | 49 | 28 |
| 24 | 49 | 40 |
| 24 | 49 | 52 |
| 24 | 49 | 64 |
| 24 | 61 | 28 |
| 24 | 61 | 40 |
| 24 | 61 | 52 |
| 24 | 61 | 64 |
***** examining a data structure referred to by a var
#+BEGIN_SRC clojure :results output
(println (first trip014))
#+END_SRC

#+RESULTS:
: (([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64]))
***** huh? de-nest wraps a list around the
#+BEGIN_SRC clojure :results output
(println (de-nestc (first trip014)))
#+END_SRC

#+RESULTS:
: ((([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
***** ah. concat needs to be applied
#+BEGIN_SRC clojure :results output
(println (apply concat (first trip014)))
#+END_SRC

#+RESULTS:
: ([24 25 28] [24 25 40] [24 25 52] [24 25 64] [24 37 28] [24 37 40] [24 37 52] [24 37 64] [24 49 28] [24 49 40] [24 49 52] [24 49 64] [24 61 28] [24 61 40] [24 61 52] [24 61 64])

#+RESULTS:

#+BEGIN_SRC clojure
(de-nestc '(([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
#+END_SRC
* converting complex common lisp functions to clojure
** set-up pairs of pc-sets
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-up (pcset1 lst-of-pcsets)
  (cond ((null lst-of-pcsets) ())
	(t (cons pcset1 
		 (cons (car lst-of-pcsets) 
		       (set-up pcset1 (cdr lst-of-pcsets)))))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 4 |   |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 | 4 | 6 |
*** clj
backwards version because of cons-ing
#+BEGIN_SRC clojure
(defn set-up [pcset1 lst-of-pcsets]
  (loop [pc1 pcset1
         pcs lst-of-pcsets
         acc ()]
    (if (empty? pcs)
      acc
      (recur pc1 (rest pcs) (cons pc1 (cons (first pcs) acc))))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up((0 1 2) (0 1 2 4 6) (0 1 2) (0 4) (0 1 2) (0 1 2))


#+BEGIN_SRC clojure
(defn set-up [pcset1 lst-of-pcsets]
  (loop [pc1 pcset1
         pcs lst-of-pcsets
         acc ()]
    (if (empty? pcs)
    (reverse acc)
      (recur pc1 (rest pcs) (conj (conj acc (first pcs)) pc1)))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up((0 1 2) (0 1 2 4 6) (0 1 2) (0 4) (0 1 2) (0 1 2))

** make pairs = partition

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun make-pairs-from-list (lst)
  "turn a list of anythings into pairs of those things, simply
conjoining every two elements"
  (cond ((null lst) ())
	(t (cons (list (first lst) (second lst))
		 (make-pairs-from-list (nthcdr 2 lst))))))

(make-pairs-from-list '(0 1 2 3 4 5 6 7 8 9))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |
 | 2 | 3 |
 | 4 | 5 |
 | 6 | 7 |
 | 8 | 9 |

*** clj

#+BEGIN_SRC clojure
(partition 2 '(0 1 2 3 4 5 6 7 8 9))
#+END_SRC

#+RESULTS:
| 0 | 1 |
| 2 | 3 |
| 4 | 5 |
| 6 | 7 |
| 8 | 9 |

** join up the first element from a given set with the rest of sets--jack-b
needs a better name!

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun jack-b (listA listA-prime)
  (cond ((null listA-prime) ())
	(t (cons 
	    (list (car listA)
		  (car listA-prime))
	    (jack-b listA (cdr listA-prime))))))

(jack-b '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
 #+END_SRC

 #+RESULTS:
 | 0 | (0 1)   |
 | 0 | (0 3)   |
 | 0 | (0 1 4) |
 | 0 | (0 1 5) |
 | 0 | (0 1)   |
 | 0 | (0 3)   |

*** clj

watch what happens when you switch up cons and conj here! Comedy ensues.

#+BEGIN_SRC clojure
(defn jack-b [lst1 lst2]
(loop [l1 lst1
       l2 lst2
       acc ()]
  (if (empty? l2) 
      acc
      (recur l1 (rest l2) (cons (list (first l1) (first l2)) acc)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/jack-b

f#+BEGIN_SRC clojure

(jack-b '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
| 0 | (0 3)   |
| 0 | (0 1)   |
| 0 | (0 1 5) |
| 0 | (0 1 4) |
| 0 | (0 3)   |
| 0 | (0 1)   |

** last1--a Graham utility

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun last1 (lst) (car (last lst)))

(last1 '((0 1)))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |

*** clj
#+BEGIN_SRC clojure
(last '((0 1)))
#+END_SRC

#+RESULTS:
| 0 | 1 |

** the ever important jack-rec--only called with make-pairs-from-lists?
*** cl
this guy does a particular kind of combinatoric setup that is
important for generating unique combinations of two chords.
That is, it will produce '((0 1) (0 2)) but not '((0 2) (0 1))

Gotta really reconsider what this is doing. Where is it in fact being
called? It looks like it might do a lot of work that might not be
necessary?? 

Or at least, the way it is being called in the final imset-code, as
quoted below, seems to be used to produce particular pairs that might
be produceable another way, esp. with clojure sequence functions.



 #+BEGIN_SRC lisp :session cl-to-cloj
(defun jack-rec (listA listA-prime)
      (cond ((null listA) ())
            (t (labels ((rec (an-x a-y)
                          (cond ((null listA) ())
                                (t (jack-b an-x a-y)))))
                 (list (rec listA listA-prime) (jack-rec (cdr listA) (cdr listA-prime)))))))


 #+END_SRC

#+BEGIN_SRC lisp :session cl-to-cloj
(jack-rec '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
| (0 (0 1))                                               | (0 (0 3)) | (0 (0 1 4)) | (0 (0 1 5)) | (0 (0 1)) | (0 (0 3)) |
| ((1 (0 3)) (1 (0 1 4)) (1 (0 1 5)) (1 (0 1)) (1 (0 3))) | NIL       |             |             |           |           |


This use of jack-rec would be almost perfectly duplicated by some
combinatorial function that did combinations WITH replacement.
#+BEGIN_SRC lisp :session cl-to-cloj
(make-pairs-from-list (de-nestc (jack-rec '((0 1) (0 2) (0 3)) '((0 1) (0 2) (0 3)))))
#+END_SRC

#+RESULTS:
| (0 1) | (0 1) |
| (0 1) | (0 2) |
| (0 1) | (0 3) |
| (0 2) | (0 2) |
| (0 2) | (0 3) |
| (0 3) | (0 3) |
| (NIL) | NIL   |

*** clj--jack-rec not necessary? 
If all jack-rec is required to do is participate in constructing pairs
of pairs, then...one must ask the question: is it possible to
construct those some other way?

#+BEGIN_SRC clojure
(defn jack-rec [lst1 lst2]
(letfn [(jackrec [inner-lst1 inner-lst2]
(cond (empty? l1) acc

#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure
(jack-rec '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
*** clj--long process for producing combinations
#+BEGIN_SRC clojure
(defn help-make-pairs [[head & tail]]
(letfn [(rec [inner-tail]
          (cond (empty? inner-tail) ()
                :else (cons (list head (first inner-tail))
                            (rec (rest inner-tail)))))]
  (rec (concat (list head) tail))))


#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/help-make-pairs

#+BEGIN_SRC clojure
(help-make-pairs '(0 1 2 3 4))
#+END_SRC				   

#+RESULTS:
| 0 | 0 |
| 0 | 1 |
| 0 | 2 |
| 0 | 3 |
| 0 | 4 |

#+BEGIN_SRC clojure
(defn make-comb-pairs-from-flat-list [coll]
  (cond (empty? coll) ()
        :else (concat (help-make-pairs coll)
                      (make-comb-pairs-from-flat-list (rest coll)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/make-comb-pairs-from-flat-list

#+BEGIN_SRC clojure :results output
(println (make-comb-pairs-from-flat-list [0 1 2 3 4 5]))
#+END_SRC

#+RESULTS:
: ((0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (1 1) (1 2) (1 3) (1 4) (1 5) (2 2) (2 3) (2 4) (2 5) (3 3) (3 4) (3 5) (4 4) (4 5) (5 5))

** set-up-Tn-equivalent-Ys-with-X

*** cl
This bad-boy will eventually be dealing with massive state. Let's see
an example?

 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-up-Tn-equivalent-Ys-with-X (pcset1 pcset2)
  (set-up pcset1 (car (tni-all (list pcset2)))))
 #+END_SRC

 #+RESULTS:
 : SET-UP-TN-EQUIVALENT-YS-WITH-X

Produces pairs of set1 and transposed versions of set2
#+BEGIN_SRC lisp :session cl-to-cloj
(set-up-tn-equivalent-ys-with-x '(0 1) '(0 1 3))
#+END_SRC

#+RESULTS:
|  0 |  1 |    |
|  0 |  1 |  3 |
|  0 |  1 |    |
|  1 |  2 |  4 |
|  0 |  1 |    |
|  2 |  3 |  5 |
|  0 |  1 |    |
|  3 |  4 |  6 |
|  0 |  1 |    |
|  4 |  5 |  7 |
|  0 |  1 |    |
|  5 |  6 |  8 |
|  0 |  1 |    |
|  6 |  7 |  9 |
|  0 |  1 |    |
|  7 |  8 | 10 |
|  0 |  1 |    |
|  8 |  9 | 11 |
|  0 |  1 |    |
|  9 | 10 |  0 |
|  0 |  1 |    |
| 10 | 11 |  1 |
|  0 |  1 |    |
| 11 |  0 |  2 |




** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun pc-compari (n1 n2)
  (cond ((<= n1 n2)
	 (cond ((= n1 n2) 0)
	       (t (1+ (pc-compari n1 (1- n2))))))
	(t (cond ((= (mod n1 12) n2) 0)
	       (t (1+ (pc-compari (1+ n1) n2)))))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun rec-do-pc-compari (lst1 lst2)
  (labels ((rec (x1 y1)
	     (cond ((null x1) ())
		   (t (cons (pc-compari (car x1) (car y1))
			    (rec (cdr x1) y1))))))
    (cond ((null lst2) ())
	  (t (cons (rec lst1 lst2)
		   (rec-do-pc-compari lst1 (cdr lst2)))))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-lewin-vector (set1 set2)
  (counting (flatten (rec-do-pc-compari set1 set2))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-straus-profile (set1 set2)
  (clean-profile (create-lewin-vector set1 set2)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12-straus-profiles (set1 set2)
  (let ((a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))))
    (labels ((rec (lst)
	       (create-straus-profile (first lst) (second lst))))
      (mapcar #'rec a))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12-lewin-vectors (set1 set2)
  (let ((a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))))
    (labels ((rec (lst)
	       (create-lewin-vector (first lst) (second lst))))
      (mapcar #'rec a))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun createA-lewin-vector (paired-set)
  (counting (flatten (rec-do-pc-compari (car paired-set) (cadr paired-set)))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-24-lewin-vectors (paired-list)
  (let* ((a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
	 (b (mapcar #'createA-lewin-vector a))
	 (c (mapcar #'reverse b)))
    (append b c)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-Astraus-profile (paired-list)
  (clean-profile (createA-lewin-vector paired-list)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12A-straus-profiles (paired-list)
  (let ((a (make-pairs-from-list 
	    (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					    (cadr paired-list)))))
    (mapcar #'create-Astraus-profile a)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun looking (mset)
  (cond ((null mset) ())
	(t (cons (count (car mset) mset)
		 (looking (cdr mset))))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun comparing (mset-list)
  (let ((canon (mapcar #'list-to-integer (mapcar #'looking mset-list))))
    (list (apply #'max canon) canon)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun locating (mset-list)
  (let ((chart (comparing mset-list)))
    (nth (1- (cadr (locate (car chart) (cadr chart)))) mset-list)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun locate (x lat)
  (let ((newlat (reverse lat)))
    (labels
	((rec (rec-x rec-lat)
	   (cond ((null rec-lat) ())
		 ((equal rec-x (car rec-lat)) 
		  (cons (length rec-lat) (rec rec-x (cdr rec-lat))))
		 (t (rec rec-x (cdr rec-lat))))))
      (cons x (reverse (rec x newlat))))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun rotate (list count)
  (if (minusp count)
      (rotate list (+ (length list) count))
      (nconc (subseq list count) (subseq list 0 count))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun my-rotate (lst)
  (let ((n (length lst)))
    (labels 
	((rec (rec-lst rec-n)
	   (if (zerop rec-n) ()
	       (list (rotate rec-lst rec-n)
		     (rec rec-lst (1- rec-n))))))
      (rec lst n))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun all-rotations (lst)
  (butlast (de-nestC (my-rotate lst))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12math (less more)
  (cond ((<= less more) (- more less))
	(t (- (+ 12 more) less))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun primer (ordered-set)
  (cond ((null ordered-set) ())
	(t (cons (mod12math (car ordered-set) (last1 ordered-set))
		 (primer (butlast ordered-set))))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun prime-vector (ordered-set)
  (let ((basic-vector (primer ordered-set)))
    (cons (car basic-vector) (butlast (reverse (butlast basic-vector))))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun wrap-vectors (ordered-set)
  (mapcar #'prime-vector (all-rotations ordered-set)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun list-to-integer (lst-of-ints)
  (let ((high-exp (length lst-of-ints)))
    (labels 
	((rec (lst place)
	   (cond ((null lst) 0)
		 (t (+ (* (car lst) (expt 10 place))
		       (rec (cdr lst) (1- place)))))))
      (rec lst-of-ints high-exp))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun find-prime-form-from-list (ordered-pcset)
  (let* ((a (all-rotations ordered-pcset))
	 (b (mapcar #'prime-vector a))
	 (c (mapcar #'list-to-integer b)))
    (nth (position (apply #'min c) c) a)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-to-zero (ordered-pcset)
  (let ((n (car ordered-pcset)))
    (mapcar #'(lambda (x) 
		(cond ((>= x n) (- x n))
		      (t (- (+ 12 x) n))))
	    ordered-pcset)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun invert-mod12-pcset (pcset)
 (sort (mapcan #'mod12 (list (mapcar #'(lambda (x) (- 12 x)) pcset))) #'<))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun Ainvert-mod12-pcset (pcset)
 (mapcan #'mod12 (list (mapcar #'(lambda (x) (- 12 x)) pcset))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun find-set-inversion (pcset)
  (set-to-zero (reverse (Ainvert-mod12-pcset pcset))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-decision (pcset)
  (let ((a (set-to-zero (find-prime-form-from-list pcset))))
    (list a (set-to-zero (find-prime-form-from-list (invert-mod12-pcset a))))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-prime (pcset)
  (let ((a (forte-decision pcset)))
    (if (every #'<= (car a) (cadr a))
	(car a)
	(cadr a))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-primeA (pcset)
  (let ((a (forte-decision pcset)))
    (another-forte (car a) (cadr a))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun another-forte (setx sety)
  (let ((a setx) (b sety))
    (labels ((rec (set1 set2)
	       (cond ((null set1) setx)
		     ((> (car set1) (car set2)) sety)
		     ((< (car set1) (car set2)) setx)
		     (t (rec (cdr set1) (cdr set2))))))
      (rec a b))))
 #+END_SRC


 ;; (defun 24create (paired-list)
 ;;   (let* ((a (make-pairs-from-list 
 ;; 	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
 ;; 					     (cadr paired-list))))
 ;; 	 (b (mapcar #'createA-lewin-vector a))
 ;; 	 (c (mapcar #'reverse b))
 ;; 	 (d (append b c))
 ;; 	 (e (mapcar #'clean-profile d)) ; effectively creates a straus-profile
 ;; 	 (f (mapcar #'multiset-forte-prime e))
 ;; 	 (g (mapcar #'multiset-forte-decision e)))
 ;;     (mapcar #'list d e f g)))

 ;; simply remove duplicates you say, eh? how would you reintroduce
 ;; them? quote unquote.


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-primeA (mset)
 (forte-primeA (remove-duplicates mset)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-prime (mset)
 (forte-prime (remove-duplicates mset)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-decision (mset)
  (forte-decision (remove-duplicates mset)))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun imset-decision-maker (paired-list)
  (let* (
	 ;; a is the "home-list", the foundation, providing all the
	 ;; paired sets across the transpositional spectrum for a given
	 ;; X-Y pair
	 (a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
	 ;; determine the IFUNC of each X-Y pair in A, where the X chord is 
	 ;; constant and Y is transposed by Tn for n from 0 to 11
	 (b (mapcar #'createA-lewin-vector a))
	 ;; also determine the INVERSE of each IFUNC simply
	 ;; at one time by reversing the lewin-vector
	 ;;
	 ;; disadvantage is that you don't get the generating pair
	 ;; explicitly, but still a neat trick on Lewin-style vectors
	 (c (mapcar #'reverse b))
	 ;; make one big list that contains all these
	 ;; lewin-vectors. we will then use this list of 24 IFUNCS in
	 ;; Lewin form to find the preferred prime-form according to the 
	 ;; prime-form algorithm of choice
	 (d (append b c))
	 ;; create the analogous 24 straus-profiles
	 (e (mapcar #'clean-profile d)) ; turns out CLEAN-PROFILE effectively creates a Straus-profile
	 ;; determine the forte prime form that the reduced
	 ;; straus multisets represent
	 ;; 
	 ;; could be replaced with Straus-Rahn algorithm if desired
	 (f (multiset-forte-primeA (car e))) ; car because only need check the first one as they
					     ; all will represent the same forteprime (why, again?)
	 ;; make all imsets into sets in order to perform
	 ;; some nifty LOCATE-ing maneuvers
	 (g (mapcar #'remove-duplicates e))
	 ;; find the location(s) of the forte prime in this 
	 ;; new list of sets
	 ;;
	 ;; NB. F is a shallow list, and contains the only the single prime-form
	 (h (locate f g))
	 ;; IMPORTANT: use the location of 
	 ;; prime-form f in the list of sets g
	 ;; to find the generating multiset parent(s) in e
	 ;; possible that there is MORE THAN ONE!
	 (i (loop for idx in (cdr h) ; must use cdr portion of LOCATE output
	       collect (nth (1- idx) e))) ;locate is not zero-indexed apparently
	 ;; leave only unique representatives generators of the
	 ;; forte-prime form. at max there should be two 
	 ;;
	 ;; NOT NECESSARILY!!! see ((0 2 4) (0 2 6))
	 (j (remove-duplicates i :test #'equal)))
	 ;; following code commented out because it failed to 
	 ;; detect the prime form in the specific tricky case 
	 ;; mentioned just above. otherwise, a hack worth
	 ;; looking at, at least for its use of EVERY
	 ;;
	 ;; (if (every #'<= (car j) (cadr j))
	 ;; 	(list 'first j)
	 ;; 	(list 'second j))))
	 ;;
	 ;;; this alone just cannot do it.
	 ;;; there must be a larger function for looking 
	 ;;; within multiset families--update: that is now
	 ;;; done by the function, LOCATING below
	 ;; do pairwise comparisons to find the imset that 
	 ;; most consistently is lower from left to right
	 ;; and use LOCATING in the special case
	 ;;
	 ;; in compilation this won't print but use for seeing
	 ;; step by step the process here
	 ;;
	 ;; (format t "~{~{~a ~%~}~%~}" (list a d e f g h i j))
    (if (<= (length j) 2)
	(if (every #'<= (car j) (cadr j))
	    (car j)
	    (cadr j))
	(locating j))))
 #+END_SRC


** 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun map-locate (loli)
  (let ((full-list loli))
   (labels ((hmm (rec-loli)
	      (cond ((null rec-loli) ())
		    (t (cons (locate (car rec-loli) full-list)
			     (hmm (cdr rec-loli)))))))
     (hmm loli))))
 #+END_SRC


