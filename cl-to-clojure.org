* converting basic common lisp functions to clojure
** basic "list adder" function
*** common lisp
#+BEGIN_SRC lisp :session cl-to-cloj
(defun list+ (n lst)
  (mapcar #'(lambda (x) (+ n x)) lst))

(list+ 12 '(0 4 7))
#+END_SRC

#+RESULTS:
| 12 | 16 | 19 |

*** clojure								:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn list+ [n lst]
  (map (fn [x] (+ n x)) lst))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/list+

#+BEGIN_SRC clojure :session cl-to-cloj
(list+ 3 [1 2 3])
#+END_SRC

#+RESULTS:
| 4 | 5 | 6 |
** generate 12 transposition of a given set
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun Tn1-11 (n pcset)     ;expects an argument of n=12
    (cond ((= n -1) ())
	  (t (cons (list+ n pcset)
		   (Tn1-11 (- n 1) pcset)))))

(Tn1-11 12 '(0 4 7))
 #+END_SRC

 #+RESULTS:
 | 12 | 16 | 19 |
 | 11 | 15 | 18 |
 | 10 | 14 | 17 |
 |  9 | 13 | 16 |
 |  8 | 12 | 15 |
 |  7 | 11 | 14 |
 |  6 | 10 | 13 |
 |  5 |  9 | 12 |
 |  4 |  8 | 11 |
 |  3 |  7 | 10 |
 |  2 |  6 |  9 |
 |  1 |  5 |  8 |
 |  0 |  4 |  7 |
*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn Tn1-11 [pcset]
  (loop [n 12
         acc ()
         ]
    (if (< n 0)
      acc
      (recur (dec n) (conj acc (list+ n pcset))))))


#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/Tn1-11

#+BEGIN_SRC clojure :session cl-to-cloj
(Tn1-11 '(0 4 7))
#+END_SRC

#+RESULTS:
|  0 |  4 |  7 |
|  1 |  5 |  8 |
|  2 |  6 |  9 |
|  3 |  7 | 10 |
|  4 |  8 | 11 |
|  5 |  9 | 12 |
|  6 | 10 | 13 |
|  7 | 11 | 14 |
|  8 | 12 | 15 |
|  9 | 13 | 16 |
| 10 | 14 | 17 |
| 11 | 15 | 18 |
| 12 | 16 | 19 |

** mod12 across a list
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12 (lst)
  (mapcar #'(lambda (x) (mod x 12)) lst))

(mod12 '(24 28 31))
 #+END_SRC

 #+RESULTS:
 | 0 | 4 | 7 |

*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn mod12 [lst]
(map #(mod % 12) lst))

(mod12 [24 28 31])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/mod12(0 4 7)

** mod12 across nested lists

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12-all (lst-of-lsts)
  (mapcar #'mod12 lst-of-lsts))

(mod12-all '((24 28 31) (36 40 43)))
 #+END_SRC

 #+RESULTS:
 | 0 | 4 | 7 |
 | 0 | 4 | 7 |

*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn mod12-all [lst-of-lsts]
(map mod12 lst-of-lsts))

(mod12-all [[24 28 31] [36 40 43]])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/mod12-all((0 4 7) (0 4 7))

** generate transposed lists from list of prime form pcset

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun TnI-all (lol-of-pcsets)
 (mapcar #'(lambda (x) (reverse (mod12-all (Tn1-11 11 x)))) lol-of-pcsets))

(TnI-all '((0 1 2) (0 3 6)))
 #+END_SRC

 #+RESULTS:
 | (0 1 2) | (1 2 3) | (2 3 4) | (3 4 5) | (4 5 6)  | (5 6 7)  | (6 7 8) | (7 8 9)  | (8 9 10) | (9 10 11) | (10 11 0) | (11 0 1) |
 | (0 3 6) | (1 4 7) | (2 5 8) | (3 6 9) | (4 7 10) | (5 8 11) | (6 9 0) | (7 10 1) | (8 11 2) | (9 0 3)   | (10 1 4)  | (11 2 5) |

*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn TnI-all [lol-of-pcsets]
(map #(mod12-all (Tn1-11 %)) lol-of-pcsets))

(TnI-all [[0 1 2] [0 4 7]])
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/TnI-all(((0 1 2) (1 2 3) (2 3 4) (3 4 5) (4 5 6) (5 6 7) (6 7 8) (7 8 9) (8 9 10) (9 10 11) (10 11 0) (11 0 1) (0 1 2)) ((0 4 7) (1 5 8) (2 6 9) (3 7 10) (4 8 11) (5 9 0) (6 10 1) (7 11 2) (8 0 3) (9 1 4) (10 2 5) (11 3 6) (0 4 7)))

** flatten already in clojure.core
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun flatten (x)
  (labels 
      ((rec (x acc) 
	 (cond ((null x) acc) 
	       ((atom x) (cons x acc)) 
	       (t (rec (car x) (rec (cdr x) acc))))))
    (rec x nil)))
 #+END_SRC

 #+RESULTS:
 : FLATTEN


 ;; (defun count-occurrences (vector-list)
 ;;   (cond ((null vector-list) ())
 ;; ;; expects only the 12 pitch classes
 ;; 	(t (list (count 0 vector-list)
 ;; 		 (count 1 vector-list)
 ;; 		 (count 2 vector-list)
 ;; 		 (count 3 vector-list)
 ;; 		 (count 4 vector-list)
 ;; 		 (count 5 vector-list)
 ;; 		 (count 6 vector-list)
 ;; 		 (count 7 vector-list)
 ;; 		 (count 8 vector-list)
 ;; 		 (count 9 vector-list)
 ;; 		 (count 10 vector-list)
 ;; 		 (count 11 vector-list)))))

 ;; this is an exhaustive version of COUNT that is also
 ;; recursive. why does it need to use LABELS? so you don't
 ;; have to explicitly pass in '11', or so you can call 
 ;; REVERSE at the end? Probably possible to write it more simply.

* bad imperative counting data vector constructing functions
** counting? counts occurrences of elements--interval vector func
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun counting (lst-of-12ints)
  "Use COUNT to find the number of occurrences of each
 member of the list"
  (labels ((count-up (n ints)
	     (cond ((< n 0) ())
		   (t (cons (count n ints)
			    (count-up (1- n) ints))))))
    ;; assumes you want to be looking at the twelve pitch-classes
    (reverse (count-up 11 lst-of-12ints))))


(counting '(3 1 2 0 2 4 0 0 0 0 0 0))
 #+END_SRC

 #+RESULTS:
 | 7 | 1 | 2 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |


#+BEGIN_SRC lisp :session cl-to-cloj
(count 12 '(12 0 1 2 12))
#+END_SRC

#+RESULTS:
: 2

*** clj--frequencies							:clj:
**** produces a map??
#+BEGIN_SRC clojure :session cl-to-cloj :results output
(println (frequencies [3 1 2 0 2 4 0 0 0 0 0 0]))
#+END_SRC

#+RESULTS:
: {3 1, 1 1, 2 2, 0 7, 4 1}

**** clj--dealing with frequencies					:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(let [v [3 1 2 0 2 4 0 0 0 0 0 0]]
                            (for [n (range 12)]
                              (get (frequencies v ) n 0)))
#+END_SRC

#+RESULTS:
| 7 | 1 | 2 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

*** clj--counting proper						:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn counting [v]
  (for [n (range 12)]
    (get (frequencies v ) n 0)))
#+END_SRC  

#+RESULTS:
: #'post_tonal_overtone.core/counting

#+BEGIN_SRC clojure :session cl-to-cloj
(counting '(3 1 2 0 2 4 0 0 0 0 0 0))
#+END_SRC

#+RESULTS:
| 7 | 1 | 2 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

** repeat elements
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun repeating (num-element1 num-element2)
  (cond ((= 0 num-element1) ())
	(t (cons num-element2
		 (repeating (- num-element1 1) num-element2)))))

(repeating 4 6)
 #+END_SRC

 #+RESULTS:
 | 6 | 6 | 6 | 6 |

*** clj--repeat is a built-in for populating a list			:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(repeat 4 6)
#+END_SRC

#+RESULTS:
| 6 | 6 | 6 | 6 |

** frequencies vs. fixed array?
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun 12-profile (vector)
  (list (repeating (nth 0 vector) 0)
	(repeating (nth 1 vector) 1)
	(repeating (nth 2 vector) 2)
	(repeating (nth 3 vector) 3)
	(repeating (nth 4 vector) 4)
	(repeating (nth 5 vector) 5)
	(repeating (nth 6 vector) 6)
	(repeating (nth 7 vector) 7)
	(repeating (nth 8 vector) 8)
	(repeating (nth 9 vector) 9)
	(repeating (nth 10 vector) 10)
	(repeating (nth 11 vector) 11)))

(12-profile (counting '(3 1 2 0 2 4 0 0 0 0 0 0)))
 #+END_SRC

 #+RESULTS:
 | (0 0 0 0 0 0 0) | (1) | (2 2) | (3) | (4) | NIL | NIL | NIL | NIL | NIL | NIL | NIL |

*** clj--trying to get around writing 12-profile 			:clj:
**** contains? is best on maps, not lists or vectors
http://clojuredocs.org/clojure.core/contains_q

** [#A] "clean profile" flattens and removes nill
*** hide confusion
**** cl code definition
 takes a straus profile as vector as "single-vector," hence
 "clean-profile", which gets rid of 'nulls' and flattens it down into a
 single multiset
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun clean-profile (single-vector)
  (flatten (remove-if #'null (12-profile single-vector))))
 #+END_SRC
**** examples of use
***** as is
 #+BEGIN_SRC lisp :session cl-to-cloj
(clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11))
 #+END_SRC

 #+RESULTS:
 | 1 | 2 | 3 | 3 | 4 | 4 | 4 | 5 | 5 | 5 | 6 | 6 | 6 | 7 | 7 | 7 | 7 | 7 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 |

***** mapcar-ed in the multiset function

 #+BEGIN_SRC lisp :session cl-to-cloj
(mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |  2 | 11 |
 | 0 | 1 |  2 |  3 |
 | 1 | 2 |  3 |  4 |
 | 2 | 3 |  4 |  5 |
 | 3 | 4 |  5 |  6 |
 | 4 | 5 |  6 |  7 |
 | 5 | 6 |  7 |  8 |
 | 6 | 7 |  8 |  9 |
 | 7 | 8 |  9 | 10 |
 | 8 | 9 | 10 | 11 |
 | 0 | 9 | 10 | 11 |
 | 0 | 1 | 10 | 11 |
 | 0 | 9 | 10 | 11 |
 | 8 | 9 | 10 | 11 |
 | 7 | 8 |  9 | 10 |
 | 6 | 7 |  8 |  9 |
 | 5 | 6 |  7 |  8 |
 | 4 | 5 |  6 |  7 |
 | 3 | 4 |  5 |  6 |
 | 2 | 3 |  4 |  5 |
 | 1 | 2 |  3 |  4 |
 | 0 | 1 |  2 |  3 |
 | 0 | 1 |  2 | 11 |
 | 0 | 1 | 10 | 11 |

**** understanding what clean profile is doing
***** produce all intervals between two pcsets--rec-do-compari
 #+BEGIN_SRC lisp :session cl-to-cloj
(flatten (rec-do-pc-compari '(0 1) '(0 1 2)))

 #+END_SRC

 #+RESULTS:
 | 0 | 11 | 1 | 0 | 2 | 1 |

***** count up the appearances of the 12 pitch classes in that multiset--lewin
****** lisp
 #+BEGIN_SRC lisp
(counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2))))
 #+END_SRC

 #+RESULTS:
 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

****** clojure
 #+BEGIN_SRC clojure
(counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2))))
 #+END_SRC

 #+RESULTS:
 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

 #+BEGIN_SRC lisp :session cl-to-cloj

 #+END_SRC  

***** create-lewin-vector simply WRAPS counting--flatten--rec-do-pc-compari
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-lewin-vector (set1 set2)
  (counting (flatten (rec-do-pc-compari set1 set2))))
 #+END_SRC

 #+RESULTS:
 : CREATE-LEWIN-VECTOR

 #+BEGIN_SRC lisp
(counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2))))
 #+END_SRC

 #+RESULTS:
 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

***** clean profile this vector == create-straus-profile
 #+BEGIN_SRC lisp
(clean-profile (counting (flatten (rec-do-pc-compari '(0 1) '(0 1 2)))))
 #+END_SRC

 #+RESULTS:
 | 0 | 0 | 1 | 1 | 2 | 11 |



 #+RESULTS:
 : CREATE-STRAUS-PROFILE

***** clean-profile is the same as sorting the rec-do-pc-compari???
 Why did I go through all that trouble? So that I had access to a lewin
 vector if necessary?

 Rec-do requires two sets, whereas clean-profile works on a lewin
 vector. Is there any reason not to take the output of sorting the
 flatten rec-do-compari and passing THAT?

 #+BEGIN_SRC lisp :session cl-to-cloj
(sort (flatten (rec-do-pc-compari '(0 1) '(0 1 2))) #'<)
 #+END_SRC

 #+RESULTS:
 | 0 | 0 | 1 | 1 | 2 | 11 |

 #+BEGIN_SRC lisp :session cl-to-cloj
(clean-profile '(1 1 1 0 0 0 0 0 0 0 0 1))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 | 2 | 11 |

***** [#B] two create-straus-profiles--only called by create-12-straus, which goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-straus-profile (set1 set2)
  (clean-profile (create-lewin-vector set1 set2)))

(create-straus-profile '(0 1) '(0 1 2))
 #+END_SRC

 #+RESULTS:
 | 0 | 0 | 1 | 1 | 2 | 11 |

 I.e. create-straus-profile is:


 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-straus-profile (set1 set2)
  (sort (flatten (rec-do-pc-compari set1 set2)) #'<))

(create-straus-profile '(0 1) '(0 1 2))

 #+END_SRC

 #+RESULTS:
 | 0 | 0 | 1 | 1 | 2 | 11 |

**** [#A] clj?--create straus profile directly--how?			:clj:
 never finished!
 #+BEGIN_SRC clojure :session cl-to-cloj
(defn clean-profile [single-vector]
(sort (flatten (rec-do-pc-compari ))))
 #+END_SRC

 #+RESULTS:
 : #'post_tonal_overtone.core/clean-profile

*** what clean-profile produces and how it does it
#+BEGIN_SRC lisp :session cl-to-cloj
(flatten (remove-if #'null (12-profile (create-lewin-vector '(0 1) '(0 1 2)))))
#+END_SRC
#+RESULTS:
| 0 | 0 | 1 | 1 | 2 | 11 |

*** how can you do this in clojure?

#+BEGIN_SRC clojure :session cl-to-cloj
 (create-lewin-vector ' (0 1) ' (0 1 2))
#+END_SRC

#+RESULTS:
| 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

#+BEGIN_SRC clojure :session cl-to-cloj :results output
(println  (let [v (create-lewin-vector '(0 1) '(0 1 2))]
     (for [n (range 12)]
	  (repeat (nth v n) n))))
#+END_SRC
#+RESULTS:
: ((0 0) (1 1) (2) () () () () () () () () (11))

#+BEGIN_SRC clojure :session cl-to-cloj
(flatten (let [v (create-lewin-vector '(0 1) '(0 1 2))]
     (for [n (range 12)]
	  (repeat (nth v n) n))))
#+END_SRC
#+RESULTS:
| 0 | 0 | 1 | 1 | 2 | 11 |

*** like this:

#+BEGIN_SRC clojure :session cl-to-cloj
(defn clean-profile [single-vector]
  (flatten (for [n (range 12)]
             (repeat (nth single-vector n) n))))
#+END_SRC
#+RESULTS:
: #'post_tonal_overtone.core/clean-profile

#+BEGIN_SRC clojure :session cl-to-cloj
(clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11))
#+END_SRC
#+RESULTS:
| 1 | 2 | 3 | 3 | 4 | 4 | 4 | 5 | 5 | 5 | 6 | 6 | 6 | 7 | 7 | 7 | 7 | 7 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 |


* the ever intriguing de-nesting problem
** de-nesting to one level
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun de-nestC (x)
  (labels ((rec (x acc)
	     (cond ((null x) acc)
		   ((atom (car x)) (cons x acc)) 
		   (t (rec (car x) (rec (cdr x) acc)))))) 
    (rec x nil)))

(de-nestC '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7)))))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |   |   |
 | 0 | 3 |   |   |
 | 0 | 4 |   |   |
 | 0 | 4 | 5 |   |
 | 0 | 4 | 6 |   |
 | 0 | 1 | 2 | 4 |
 | 0 | 1 | 3 | 5 |
 | 0 | 1 | 4 | 6 |
 | 0 | 2 | 5 | 7 |

*** clj--far more complicated; whence apply concat?			:clj:
**** concat--doesn't make much sense by itself...
#+BEGIN_SRC clojure :results output
(println (concat '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7))))))
#+END_SRC

#+RESULTS:
: ((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7))))

**** process
***** basic example with pure lists--as expected from cl
#+BEGIN_SRC clojure
(de-nestc '((0 1) ((0 3) (0 4) ((0 4 5) (0 4 6))) (((0 1 2 4) (0 1 3 5)) ((0 1 4 6) (0 2 5 7)))))
#+END_SRC

#+RESULTS:
| 0 | 1 |   |   |
| 0 | 3 |   |   |
| 0 | 4 |   |   |
| 0 | 4 | 5 |   |
| 0 | 4 | 6 |   |
| 0 | 1 | 2 | 4 |
| 0 | 1 | 3 | 5 |
| 0 | 1 | 4 | 6 |
| 0 | 2 | 5 | 7 | 

***** basic example with lists of vectors--still as expected from cl
#+BEGIN_SRC clojure
(de-nestc '(([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
#+END_SRC  

#+RESULTS:
| 24 | 25 | 28 |
| 24 | 25 | 40 |
| 24 | 25 | 52 |
| 24 | 25 | 64 |
| 24 | 37 | 28 |
| 24 | 37 | 40 |
| 24 | 37 | 52 |
| 24 | 37 | 64 |
| 24 | 49 | 28 |
| 24 | 49 | 40 |
| 24 | 49 | 52 |
| 24 | 49 | 64 |
| 24 | 61 | 28 |
| 24 | 61 | 40 |
| 24 | 61 | 52 |
| 24 | 61 | 64 |
***** examining a data structure referred to by a var
#+BEGIN_SRC clojure :results output
(println (first trip014))
#+END_SRC

#+RESULTS:
: (([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64]))
***** huh? de-nest wraps a list around the
#+BEGIN_SRC clojure :results output
(println (de-nestc (first trip014)))
#+END_SRC

#+RESULTS:
: ((([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
***** ah. concat needs to be applied
#+BEGIN_SRC clojure :results output
(println (apply concat (first trip014)))
#+END_SRC

#+RESULTS:
: ([24 25 28] [24 25 40] [24 25 52] [24 25 64] [24 37 28] [24 37 40] [24 37 52] [24 37 64] [24 49 28] [24 49 40] [24 49 52] [24 49 64] [24 61 28] [24 61 40] [24 61 52] [24 61 64])

#+RESULTS:

#+BEGIN_SRC clojure
(de-nestc '(([24 25 28] [24 25 40] [24 25 52] [24 25 64]) ([24 37 28] [24 37 40] [24 37 52] [24 37 64]) ([24 49 28] [24 49 40] [24 49 52] [24 49 64]) ([24 61 28] [24 61 40] [24 61 52] [24 61 64])))
#+END_SRC
*** clj--de-nestc code							:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn de-nestc [x]
  (letfn [(denester [inner-x acc]
            (let [coll inner-x]
              (cond (empty? coll) acc
                    (not (counted? (first coll))) (cons coll acc)
                    :else (denester (first coll) (denester (rest coll) acc)))))]
    (denester x ())))



#+END_SRC

#+BEGIN_SRC clojure :results output
(println (apply concat (first trip014)))
#+END_SRC

#+RESULTS:
: ([24 25 28] [24 25 40] [24 25 52] [24 25 64] [24 37 28] [24 37 40] [24 37 52] [24 37 64] [24 49 28] [24 49 40] [24 49 52] [24 49 64] [24 61 28] [24 61 40] [24 61 52] [24 61 64])

* converting complex common lisp functions to clojure
** set-up pairs of pc-sets
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-up (pcset1 lst-of-pcsets)
  (cond ((null lst-of-pcsets) ())
	(t (cons pcset1 
		 (cons (car lst-of-pcsets) 
		       (set-up pcset1 (cdr lst-of-pcsets)))))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 4 |   |   |   |
 | 0 | 1 | 2 |   |   |
 | 0 | 1 | 2 | 4 | 6 |
*** clj									:clj:
backwards version because of cons-ing
#+BEGIN_SRC clojure
(defn set-up [pcset1 lst-of-pcsets]
  (loop [pc1 pcset1
         pcs lst-of-pcsets
         acc ()]
    (if (empty? pcs)
      acc
      (recur pc1 (rest pcs) (cons pc1 (cons (first pcs) acc))))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up((0 1 2) (0 1 2 4 6) (0 1 2) (0 4) (0 1 2) (0 1 2))


#+BEGIN_SRC clojure
(defn set-up [pcset1 lst-of-pcsets]
  (loop [pc1 pcset1
         pcs lst-of-pcsets
         acc ()]
    (if (empty? pcs)
    (reverse acc)
      (recur pc1 (rest pcs) (conj (conj acc (first pcs)) pc1)))))

(set-up '(0 1 2) '((0 1 2) (0 4) (0 1 2 4 6)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up((0 1 2) (0 1 2 4 6) (0 1 2) (0 4) (0 1 2) (0 1 2))

** make pairs = partition

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun make-pairs-from-list (lst)
  "turn a list of anythings into pairs of those things, simply
conjoining every two elements"
  (cond ((null lst) ())
	(t (cons (list (first lst) (second lst))
		 (make-pairs-from-list (nthcdr 2 lst))))))

(make-pairs-from-list '(0 1 2 3 4 5 6 7 8 9))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |
 | 2 | 3 |
 | 4 | 5 |
 | 6 | 7 |
 | 8 | 9 |

*** clj									:clj:

#+BEGIN_SRC clojure
(partition 2 '(0 1 2 3 4 5 6 7 8 9))
#+END_SRC

#+RESULTS:
| 0 | 1 |
| 2 | 3 |
| 4 | 5 |
| 6 | 7 |
| 8 | 9 |
#+BEGIN_SRC clojure :session cl-to-cloj
(defn make-pairs-from-list [lst]
(partition 2 lst))

(make-pairs-from-list '(0 1 2 3 4 5 6 7 8 9))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/make-pairs-from-list((0 1) (2 3) (4 5) (6 7) (8 9))

** join up the first element from a given set with the rest of sets--jack-b
needs a better name!

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun jack-b (listA listA-prime)
  (cond ((null listA-prime) ())
	(t (cons 
	    (list (car listA)
		  (car listA-prime))
	    (jack-b listA (cdr listA-prime))))))

(jack-b '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
 #+END_SRC

 #+RESULTS:
 | 0 | (0 1)   |
 | 0 | (0 3)   |
 | 0 | (0 1 4) |
 | 0 | (0 1 5) |
 | 0 | (0 1)   |
 | 0 | (0 3)   |

*** clj									:clj:

watch what happens when you switch up cons and conj here! Comedy ensues.

#+BEGIN_SRC clojure
(defn jack-b [lst1 lst2]
(loop [l1 lst1
       l2 lst2
       acc ()]
  (if (empty? l2) 
      acc
      (recur l1 (rest l2) (cons (list (first l1) (first l2)) acc)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/jack-b

f#+BEGIN_SRC clojure

(jack-b '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
| 0 | (0 3)   |
| 0 | (0 1)   |
| 0 | (0 1 5) |
| 0 | (0 1 4) |
| 0 | (0 3)   |
| 0 | (0 1)   |

** last1--a Graham utility

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun last1 (lst) (car (last lst)))

(last1 '((0 1)))
 #+END_SRC

 #+RESULTS:
 | 0 | 1 |

*** clj									:clj:
#+BEGIN_SRC clojure
(last '((0 1)))
#+END_SRC

#+RESULTS:
| 0 | 1 |

** the ever important jack-rec--only called with make-pairs-from-lists?
*** cl
this guy does a particular kind of combinatoric setup that is
important for generating unique combinations of two chords.
That is, it will produce '((0 1) (0 2)) but not '((0 2) (0 1))

Gotta really reconsider what this is doing. Where is it in fact being
called? It looks like it might do a lot of work that might not be
necessary?? 

Or at least, the way it is being called in the final imset-code, as
quoted below, seems to be used to produce particular pairs that might
be produceable another way, esp. with clojure sequence functions.



 #+BEGIN_SRC lisp :session cl-to-cloj
(defun jack-rec (listA listA-prime)
      (cond ((null listA) ())
            (t (labels ((rec (an-x a-y)
                          (cond ((null listA) ())
                                (t (jack-b an-x a-y)))))
                 (list (rec listA listA-prime) (jack-rec (cdr listA) (cdr listA-prime)))))))


 #+END_SRC

#+BEGIN_SRC lisp :session cl-to-cloj
(jack-rec '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
| (0 (0 1))                                               | (0 (0 3)) | (0 (0 1 4)) | (0 (0 1 5)) | (0 (0 1)) | (0 (0 3)) |
| ((1 (0 3)) (1 (0 1 4)) (1 (0 1 5)) (1 (0 1)) (1 (0 3))) | NIL       |             |             |           |           |


This use of jack-rec would be almost perfectly duplicated by some
combinatorial function that did combinations WITH replacement.
#+BEGIN_SRC lisp :session cl-to-cloj
(make-pairs-from-list (de-nestc (jack-rec '((0 1) (0 2) (0 3)) '((0 1) (0 2) (0 3)))))
#+END_SRC

#+RESULTS:
| (0 1) | (0 1) |
| (0 1) | (0 2) |
| (0 1) | (0 3) |
| (0 2) | (0 2) |
| (0 2) | (0 3) |
| (0 3) | (0 3) |
| (NIL) | NIL   |

*** clj--jack-rec not necessary?					:clj:
If all jack-rec is required to do is participate in constructing pairs
of pairs, then...one must ask the question: is it possible to
construct those some other way?

#+BEGIN_SRC clojure
(defn jack-rec [lst1 lst2]
(letfn [(jackrec [inner-lst1 inner-lst2]
(cond (empty? l1) acc)))))

#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure
(jack-rec '(0 1) '((0 1) (0 3) (0 1 4) (0 1 5) (0 1) (0 3)))
#+END_SRC

#+RESULTS:
*** clj--long process for producing combinations			:clj:
#+BEGIN_SRC clojure
(defn help-make-pairs [[head & tail]]
(letfn [(rec [inner-tail]
          (cond (empty? inner-tail) ()
                :else (cons (list head (first inner-tail))
                            (rec (rest inner-tail)))))]
  (rec (concat (list head) tail))))


#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/help-make-pairs

#+BEGIN_SRC clojure
(help-make-pairs '(0 1 2 3 4))
#+END_SRC				   

#+RESULTS:
| 0 | 0 |
| 0 | 1 |
| 0 | 2 |
| 0 | 3 |
| 0 | 4 |

#+BEGIN_SRC clojure
(defn make-comb-pairs-from-flat-list [coll]
  (cond (empty? coll) ()
        :else (concat (help-make-pairs coll)
                      (make-comb-pairs-from-flat-list (rest coll)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/make-comb-pairs-from-flat-list

#+BEGIN_SRC clojure :results output
(println (make-comb-pairs-from-flat-list [0 1 2 3 4 5]))
#+END_SRC

#+RESULTS:
: ((0 0) (0 1) (0 2) (0 3) (0 4) (0 5) (1 1) (1 2) (1 3) (1 4) (1 5) (2 2) (2 3) (2 4) (2 5) (3 3) (3 4) (3 5) (4 4) (4 5) (5 5))

** set-up-Tn-equivalent-Ys-with-X
*** cl
This bad-boy will eventually be dealing with massive state. Let's see
an example?

 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-up-Tn-equivalent-Ys-with-X (pcset1 pcset2)
  (set-up pcset1 (car (tni-all (list pcset2)))))
 #+END_SRC

 #+RESULTS:
 : SET-UP-TN-EQUIVALENT-YS-WITH-X

Produces pairs of set1 and transposed versions of set2
#+BEGIN_SRC lisp :session cl-to-cloj
(set-up-tn-equivalent-ys-with-x '(0 1) '(0 1 3))
#+END_SRC

#+RESULTS:
|  0 |  1 |    |
|  0 |  1 |  3 |
|  0 |  1 |    |
|  1 |  2 |  4 |
|  0 |  1 |    |
|  2 |  3 |  5 |
|  0 |  1 |    |
|  3 |  4 |  6 |
|  0 |  1 |    |
|  4 |  5 |  7 |
|  0 |  1 |    |
|  5 |  6 |  8 |
|  0 |  1 |    |
|  6 |  7 |  9 |
|  0 |  1 |    |
|  7 |  8 | 10 |
|  0 |  1 |    |
|  8 |  9 | 11 |
|  0 |  1 |    |
|  9 | 10 |  0 |
|  0 |  1 |    |
| 10 | 11 |  1 |
|  0 |  1 |    |
| 11 |  0 |  2 |

*** clj									:clj:
**** clj prepare-set-up
#+BEGIN_SRC clojure :session cl-to-cloj
(defn prepare-set-up-tn-equivalent-Ys-with-x [pcset1 pcset2]
 (set-up pcset1 (first (TnI-all (list pcset2)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/prepare-set-up-tn-equivalent-Ys-with-x

**** clj-- produces wrong order!!!
(set-up-Tn-equivalent-Ys-with-X set1 set2)
#+BEGIN_SRC clojure :session cl-to-cloj
(defn set-up-Tn-equivalent-Ys-with-X [pcset1 pcset2]
(map reverse (partition 2 (prepare-set-up-tn-equivalent-Ys-with-x '(0 1) '(0 1 3)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/set-up-Tn-equivalent-Ys-with-X

**** requirees two steps
#+BEGIN_SRC clojure :session cl-to-cloj
(map reverse (partition 2 (set-up-tn-equivalent-ys-with-x '(0 1) '(0 1 3))))
#+END_SRC

#+RESULTS:
| (0 1) | (0 1 3)   |
| (0 1) | (1 2 4)   |
| (0 1) | (2 3 5)   |
| (0 1) | (3 4 6)   |
| (0 1) | (4 5 7)   |
| (0 1) | (5 6 8)   |
| (0 1) | (6 7 9)   |
| (0 1) | (7 8 10)  |
| (0 1) | (8 9 11)  |
| (0 1) | (9 10 0)  |
| (0 1) | (10 11 1) |
| (0 1) | (11 0 2)  |
| (0 1) | (0 1 3)   |

Yikes! Reversing this corrects the order but transposes the wrong chord.
#+BEGIN_SRC clojure :session cl-to-cloj :results output
(println (set-up-tn-equivalent-ys-with-x  '(0 1 3) '(0 1)))
#+END_SRC

#+RESULTS:
: ((0 1) (0 1 3) (1 2) (0 1 3) (2 3) (0 1 3) (3 4) (0 1 3) (4 5) (0 1 3) (5 6) (0 1 3) (6 7) (0 1 3) (7 8) (0 1 3) (8 9) (0 1 3) (9 10) (0 1 3) (10 11) (0 1 3) (11 0) (0 1 3) (0 1) (0 1 3))

** pc-compari performs some pitch-class mod12 interval arithmetic
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun pc-compari (n1 n2)
  (cond ((<= n1 n2) (cond ((= n1 n2) 0)
			  (t (1+ (pc-compari n1 (1- n2))))))
	(t (cond ((= (mod n1 12) n2) 0)
		 (t (1+ (pc-compari (1+ n1) n2)))))))
 #+END_SRC

 #+RESULTS:
 : PC-COMPARI

#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 0 11)
#+END_SRC 

#+RESULTS:
: 11

#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 12 0)
#+END_SRC

#+RESULTS:
: 0
#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 11 0)
#+END_SRC

#+RESULTS:
: 1

*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn pc-compari [n1 n2]
  (cond (<= n1 n2) (cond (= n1 n2) 0
                         :else (inc (pc-compari n1 (dec n2))))
        :else (cond (= (mod n1 12) n2) 0
                    :else (inc (pc-compari (inc n1) n2)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/pc-compari


#+BEGIN_SRC clojure :session cl-to-cloj
(pc-compari 0 12)
#+END_SRC

#+RESULTS:
: 12

#+BEGIN_SRC clojure :session cl-to-cloj
(pc-compari 11 0)
#+END_SRC

#+RESULTS:
: 1

** recursively do the pc-comparing

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun rec-do-pc-compari (lst1 lst2)
  (labels ((rec (x1 y1)
	     (cond ((null x1) ())
		   (t (cons (pc-compari (car x1) (car y1))
			    (rec (cdr x1) y1))))))
    (cond ((null lst2) ())
	  (t (cons (rec lst1 lst2)
		   (rec-do-pc-compari lst1 (cdr lst2)))))))
 #+END_SRC

 #+RESULTS:
 : REC-DO-PC-COMPARI

#+BEGIN_SRC lisp :session cl-to-cloj
(rec-do-pc-compari '(0 1 2) '(0 1 3))
#+END_SRC

#+RESULTS:
| 0 | 11 | 10 |
| 1 |  0 | 11 |
| 3 |  2 |  1 |

*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn rec-do-pc-compari [lst1 lst2]
  (letfn [(rec [l1 l2]
                   (cond (empty? l1) ()
                         :else (cons (pc-compari (first l1) (first l2))
                                     (rec (rest l1) l2))))]
    (cond (empty? lst2) ()
          :else (cons (rec lst1 lst2)
                      (rec-do-pc-compari lst1 (rest lst2))))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/rec-do-pc-compari
#+BEGIN_SRC clojure :session cl-to-cloj
(rec-do-pc-compari '(0 1 2) '(0 1 3))
#+END_SRC

#+RESULTS:
| 0 | 11 | 10 |
| 1 |  0 | 11 |
| 3 |  2 |  1 |

* wrap various functions from above
** createA-lewin-vector--called by IMSET-DECISION-MAKER
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun createA-lewin-vector (paired-set)
  (counting (flatten (rec-do-pc-compari (car paired-set) (cadr paired-set)))))
 #+END_SRC

 #+RESULTS:
 : CREATEA-LEWIN-VECTOR
#+BEGIN_SRC lisp :session cl-to-cloj
(createA-lewin-vector '((0 1) (0 2)))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
** [#B] create-lewin-vector--only called by functions never called
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-lewin-vector (set1 set2)
  (counting (flatten (rec-do-pc-compari set1 set2))))
 #+END_SRC

 #+RESULTS:
 : CREATE-LEWIN-VECTOR

#+BEGIN_SRC lisp :session cl-to-cloj
(create-lewin-vector '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

*** clj									:clj:
 #+BEGIN_SRC clojure :session cl-to-cloj
(defn create-lewin-vector [set1 set2]
  (counting (flatten (rec-do-pc-compari set1 set2))))
 #+END_SRC

 #+RESULTS:
 : #'post_tonal_overtone.core/create-lewin-vector

#+BEGIN_SRC clojure :session cl-to-cloj
(create-lewin-vector '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

** [#B] create-straus-profile--only called by?
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-straus-profile (set1 set2)
  (clean-profile (create-lewin-vector set1 set2)))
 #+END_SRC

 #+RESULTS:
 : CREATE-STRAUS-PROFILE

*** clj									:clj:



#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-straus-profile [set1 set2]
  (clean-profile (create-lewin-vector set1 set2)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-straus-profile [set1 set2]
  (sort (flatten (rec-do-pc-compari set1 set2))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/create-straus-profile

#+BEGIN_SRC clojure :session cl-to-cloj
(create-straus-profile '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 11 |

** [#B] create-12-straus-profiles--goes uncalled?

*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12-straus-profiles (set1 set2)
  (let ((a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))))
    (labels ((rec (lst)
	       (create-straus-profile (first lst) (second lst))))
      (mapcar #'rec a))))
 #+END_SRC

 #+RESULTS:
 : CREATE-12-STRAUS-PROFILES

#+BEGIN_SRC lisp :session cl-to-cloj
(create-12-straus-profiles '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 0 | 1 |  2 | 11 |
| 0 | 1 |  2 |  3 |
| 1 | 2 |  3 |  4 |
| 2 | 3 |  4 |  5 |
| 3 | 4 |  5 |  6 |
| 4 | 5 |  6 |  7 |
| 5 | 6 |  7 |  8 |
| 6 | 7 |  8 |  9 |
| 7 | 8 |  9 | 10 |
| 8 | 9 | 10 | 11 |
| 0 | 9 | 10 | 11 |
| 0 | 1 | 10 | 11 |

*** clj--make-pairs-from list redunant					:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-12-straus-profiles [set1 set2]
  (let [a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))]
    (letfn [(rec [lst]
              (create-straus-profile (first lst) (second lst)))]
      (map rec a))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/create-12-straus-profiles

#+BEGIN_SRC clojure :session cl-to-cloj
(defn create-12-straus-profiles [set1 set2]
  (let [a (set-up-Tn-equivalent-Ys-with-X set1 set2)]
    (letfn [(rec [lst]
              (create-straus-profile (first lst) (second lst)))]
      (map rec a))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/create-12-straus-profiles

#+BEGIN_SRC clojure :session cl-to-cloj
(create-12-straus-profiles '(0 1) '(0 2))
#+END_SRC

#+RESULTS:
| 0 | 0 | 1 |  2 |  3 | 11 |
| 0 | 1 | 1 |  2 |  3 |  4 |
| 1 | 2 | 2 |  3 |  4 |  5 |
| 2 | 3 | 3 |  4 |  5 |  6 |
| 3 | 4 | 4 |  5 |  6 |  7 |
| 4 | 5 | 5 |  6 |  7 |  8 |
| 5 | 6 | 6 |  7 |  8 |  9 |
| 6 | 7 | 7 |  8 |  9 | 10 |
| 7 | 8 | 8 |  9 | 10 | 11 |
| 0 | 8 | 9 |  9 | 10 | 11 |
| 0 | 1 | 9 | 10 | 10 | 11 |
| 0 | 1 | 2 | 10 | 11 | 11 |
| 0 | 0 | 1 |  2 |  3 | 11 |

** [#B] create-12-lewin-vectors--goes uncalled?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12-lewin-vectors (set1 set2)
  (let ((a (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X set1 set2))))
    (labels ((rec (lst)
	       (create-lewin-vector (first lst) (second lst))))
      (mapcar #'rec a))))
 #+END_SRC

 #+RESULTS:
 : CREATE-12-LEWIN-VECTORS

** [#B] create-24-lewin-vectors--goes uncalled?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-24-lewin-vectors (paired-list)
  (let* ((a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
	 (b (mapcar #'createA-lewin-vector a))
	 (c (mapcar #'reverse b)))
    (append b c)))
 #+END_SRC

** [#B] create-Astraus-profile--called only by create-12A, which goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-Astraus-profile (paired-list)
  (clean-profile (createA-lewin-vector paired-list)))
 #+END_SRC

** [#B] create-12A-straus-profiles
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun create-12A-straus-profiles (paired-list)
  (let ((a (make-pairs-from-list 
	    (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					    (cadr paired-list)))))
    (mapcar #'create-Astraus-profile a)))
 #+END_SRC

* set searching
** looking--is called by comparing
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun looking (mset)
  (cond ((null mset) ())
	(t (cons (count (car mset) mset)
		 (looking (cdr mset))))))
 #+END_SRC

 #+RESULTS:
 : LOOKING
#+BEGIN_SRC lisp :session cl-to-cloj
(mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))))
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |

#+BEGIN_SRC lisp :session cl-to-cloj
(reverse (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2)))))
#+END_SRC

#+RESULTS:
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |

#+BEGIN_SRC lisp :session cl-to-cloj
(append (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))))
	(reverse (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2)))))
)
#+END_SRC

#+RESULTS:
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
#+BEGIN_SRC lisp :session cl-to-cloj
(mapcar #'clean-profile (append (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))))
	   (reverse (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2)))))
	   ))
#+END_SRC

#+RESULTS:
| 0 | 1 |  2 | 11 |
| 0 | 1 |  2 |  3 |
| 1 | 2 |  3 |  4 |
| 2 | 3 |  4 |  5 |
| 3 | 4 |  5 |  6 |
| 4 | 5 |  6 |  7 |
| 5 | 6 |  7 |  8 |
| 6 | 7 |  8 |  9 |
| 7 | 8 |  9 | 10 |
| 8 | 9 | 10 | 11 |
| 0 | 9 | 10 | 11 |
| 0 | 1 | 10 | 11 |
| 0 | 1 | 10 | 11 |
| 0 | 9 | 10 | 11 |
| 8 | 9 | 10 | 11 |
| 7 | 8 |  9 | 10 |
| 6 | 7 |  8 |  9 |
| 5 | 6 |  7 |  8 |
| 4 | 5 |  6 |  7 |
| 3 | 4 |  5 |  6 |
| 2 | 3 |  4 |  5 |
| 1 | 2 |  3 |  4 |
| 0 | 1 |  2 |  3 |
| 0 | 1 |  2 | 11 |

** comparing--is called by locating
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun comparing (mset-list)
  (let ((canon (mapcar #'list-to-integer (mapcar #'looking mset-list))))
    (list (apply #'max canon) canon)))
 #+END_SRC

 #+RESULTS:
 : COMPARING

** locating--only called once. deals with an edge case
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun locating (mset-list)
  (let ((chart (comparing mset-list)))
    (nth (1- (cadr (locate (car chart) (cadr chart)))) mset-list)))
 #+END_SRC

 #+RESULTS:
 : LOCATING

#+BEGIN_SRC lisp :session cl-to-cloj
(locating '((0 1 2 3)))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 |

** locate--called once prominently, a kind of database lookup
*** 
*** cl--finds the occurrence of a value at a certain place in a list

why does this return the value that was searched for as well as the
location? Some peculiarity of where it is called?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun locate (x lat)
  (let ((newlat (reverse lat)))
    (labels
	((rec (rec-x rec-lat)
	   (cond ((null rec-lat) ())
		 ((equal rec-x (car rec-lat)) 
		  (cons (length rec-lat) (rec rec-x (cdr rec-lat))))
		 (t (rec rec-x (cdr rec-lat))))))
      (cons x (reverse (rec x newlat))))))
 #+END_SRC

 #+RESULTS:
 : LOCATE

#+BEGIN_SRC lisp :session cl-to-cloj
(locate 10 '(0 100 10 1000 10 100000))
#+END_SRC

#+RESULTS:
| 10 | 3 | 5 |
*** clj--can't quite use keep-indexed as locate 			:clj:
taken from SO discussions about indices and finding
http://stackoverflow.com/questions/4830900/how-do-i-find-the-index-of-an-item-in-a-vector
http://stackoverflow.com/questions/8641305/find-index-of-an-element-matching-a-predicate-in-clojure

#+BEGIN_SRC clojure :session cl-to-cloj
(defn positions
  [pred coll]
  (keep-indexed (fn [idx x]
                  (when (pred x)
                    idx))
                coll))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/positions

#+BEGIN_SRC clojure :session cl-to-cloj
(positions #(= % 10) '(0 100 10 1000 10 100000))
#+END_SRC

#+RESULTS:
| 2 | 4 |

* prime-form utilities
** rotate
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun rotate (list count)
  (if (minusp count)
      (rotate list (+ (length list) count))
      (nconc (subseq list count) (subseq list 0 count))))
 #+END_SRC

 #+RESULTS:
 : ROTATE

#+BEGIN_SRC lisp :session cl-to-cloj
(rotate '(0 1 2 11) 1)
#+END_SRC

#+RESULTS:
| 1 | 2 | 11 | 0 |

#+BEGIN_SRC lisp :session cl-to-cloj
(rotate '(0 1 2 11) 2)

#+END_SRC

#+RESULTS:
| 2 | 11 | 0 | 1 |
*** the calling dependency list
1. rotate
2. my-rotate
3. all-rotations
4. wrap-vectors--uncalled
   1. find-prime-form
   2. forte-decision
   3. forte-primeA
   4. multiset-forte-primeA
   5. imset-decision-maker

#+BEGIN_SRC lisp :session cl-to-cloj

#+END_SRC
** my-rotate
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun my-rotate (lst)
  (let ((n (length lst)))
    (labels 
	((rec (rec-lst rec-n)
	   (if (zerop rec-n) ()
	       (list (rotate rec-lst rec-n)
		     (rec rec-lst (1- rec-n))))))
      (rec lst n))))
 #+END_SRC

 #+RESULTS:
 : MY-ROTATE

#+BEGIN_SRC lisp :session cl-to-cloj
(my-rotate '(0 1 2 11))
#+END_SRC

#+RESULTS:
|          0 |                             1 | 2 | 11 |
| (11 0 1 2) | ((2 11 0 1) ((1 2 11 0) NIL)) |   |    |

** all-rotations--jump in with overtone
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun all-rotations (lst)
  (butlast (de-nestC (my-rotate lst))))
 #+END_SRC

 #+RESULTS:
 : ALL-ROTATIONS

#+BEGIN_SRC lisp :session cl-to-cloj
(all-rotations '(0 1 2 11))

#+END_SRC

#+RESULTS:
|  0 |  1 |  2 | 11 |
| 11 |  0 |  1 |  2 |
|  2 | 11 |  0 |  1 |
|  1 |  2 | 11 |  0 |
*** clj									:clj:
Should I be relying on an external library like this?

Also, the for loop using rotate will return in the reverse order unless
acted upon. Will this matter? I don't think so, but consider building
the above functions in clojure as well.
#+BEGIN_SRC clojure :session cl-to-cloj
(overtone.core/rotate 1 [0 1 3 4])
#+END_SRC

#+RESULTS:
| 1 | 3 | 4 | 0 |

#+BEGIN_SRC clojure :session cl-to-cloj
(defn all-rotations [lst]
(let [len (count lst)]
(for [n (range len)]
(overtone.core/rotate n lst))) )
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/all-rotations

#+BEGIN_SRC clojure :session cl-to-cloj
(all-rotations '(0 1 2 11))
#+END_SRC

#+RESULTS:
|  0 |  1 |  2 | 11 |
|  1 |  2 | 11 |  0 |
|  2 | 11 |  0 |  1 |
| 11 |  0 |  1 |  2 |

** mod12math--redundant? called only by primer
*** cl

 #+BEGIN_SRC lisp :session cl-to-cloj
(defun mod12math (less more)
  (cond ((<= less more) (- more less))
	(t (- (+ 12 more) less))))
 #+END_SRC

 #+RESULTS:
 : MOD12MATH

#+BEGIN_SRC lisp :session cl-to-cloj
(mod12math 0 1)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC lisp :session cl-to-cloj
(mod12math 11 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC lisp :session cl-to-cloj
(mod12math 12 0)
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 11 2)
#+END_SRC

#+RESULTS:
: 3

#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 0 1)
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC lisp :session cl-to-cloj
(pc-compari 12 0)
#+END_SRC

#+RESULTS:
: 0

** primer--needs documentation
*** cl--this transformation is then transformed by prime-vector oddly?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun primer (ordered-set)
  (cond ((null ordered-set) ())
	(t (cons (mod12math (car ordered-set) (last1 ordered-set))
		 (primer (butlast ordered-set))))))
 #+END_SRC

 #+RESULTS:
 : PRIMER

#+BEGIN_SRC lisp :session cl-to-cloj
(primer '(11 0 1 2))
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 | 0 |
*** clj--primer calls last, which in the cl version I've called last1	:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn primer [ordered-set]
  (cond (empty? ordered-set) ()
        :else (cons (pc-compari (first ordered-set) (last ordered-set))
                    (primer (butlast ordered-set)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/primer
#+BEGIN_SRC clojure :session cl-to-cloj
(primer '(11 0 1 2))
#+END_SRC

#+RESULTS:
| 3 | 2 | 1 | 0 |

** prime-vector--called only by find-prime-form (and wrap vector, which is uncalled)
*** cl--odd transformation
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun prime-vector (ordered-set)
  (let ((basic-vector (primer ordered-set)))
    (cons (car basic-vector) (butlast (reverse (butlast basic-vector))))))
 #+END_SRC

 #+RESULTS:
 : PRIME-VECTOR

#+BEGIN_SRC lisp :session cl-to-cloj
(prime-vector '(11 0 1 2))
#+END_SRC

#+RESULTS:
| 3 | 1 | 2 |
*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn prime-vector [ordered-set]
  (let [basic-vector (primer ordered-set)]
    (cons (first basic-vector) (butlast (reverse (butlast basic-vector))))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/prime-vector

#+BEGIN_SRC clojure :session cl-to-cloj
(prime-vector '(11 0 1 2))
#+END_SRC

#+RESULTS:
| 3 | 1 | 2 |

** list-to-integer--called by find-prime-form and comparing
*** cl

Why does this add a zero?
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun list-to-integer (lst-of-ints)
  (let ((high-exp (length lst-of-ints)))
    (labels 
	((rec (lst place)
	   (cond ((null lst) 0)
		 (t (+ (* (car lst) (expt 10 place))
		       (rec (cdr lst) (1- place)))))))
      (rec lst-of-ints high-exp))))
 #+END_SRC

 #+RESULTS:
 : LIST-TO-INTEGER

#+BEGIN_SRC lisp :session cl-to-cloj
(list-to-integer ' (11 2 6 7))
#+END_SRC

#+RESULTS:
: 112670
*** clj--can be done with library function?				:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(Integer/parseInt (str 11 2 6 7))
#+END_SRC

#+RESULTS:
: 11267

#+BEGIN_SRC clojure :session cl-to-cloj
(defn list-to-integer [lst-of-ints] (Integer/parseInt (apply str lst-of-ints)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/list-to-integer
#+BEGIN_SRC clojure :session cl-to-cloj
(list-to-integer '(11 2 6 7))
#+END_SRC

#+RESULTS:
: 11267

** find-prime-form-from-list--calls all-rotations, prime-vector, list-to-integer
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun find-prime-form-from-list (ordered-pcset)
  (let* ((a (all-rotations ordered-pcset))
	 (b (mapcar #'prime-vector a))
	 (c (mapcar #'list-to-integer b)))
    (nth (position (apply #'min c) c) a)))
 #+END_SRC

 #+RESULTS:
 : FIND-PRIME-FORM-FROM-LIST

#+BEGIN_SRC lisp :session cl-to-cloj
(find-prime-form-from-list '(0 1 5 6 8))
#+END_SRC

#+RESULTS:
| 5 | 6 | 8 | 0 | 1 |
*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn find-prime-form-from-list [ordered-pcset]
  (let [a (all-rotations ordered-pcset)
        b (map prime-vector a)
        c (map list-to-integer b)
        d (apply min c)]
    (nth a (first (positions #(= d %) c)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/find-prime-form-from-list

#+BEGIN_SRC clojure :session cl-to-cloj
(find-prime-form-from-list '(0 1 5 6 8))
#+END_SRC

#+RESULTS:
| 5 | 6 | 8 | 0 | 1 |

** set-to-zero--called by forte decision
*** cl--refactor 'cond' to 'if'
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun set-to-zero (ordered-pcset)
  (let ((n (car ordered-pcset)))
    (mapcar #'(lambda (x) 
		(cond ((>= x n) (- x n))
		      (t (- (+ 12 x) n))))
	    ordered-pcset)))
 #+END_SRC

 #+RESULTS:
 : SET-TO-ZERO
#+BEGIN_SRC lisp :session cl-to-cloj
(set-to-zero '(1 2 3 5))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 4 |
*** clj
#+BEGIN_SRC clojure :session cl-to-cloj
(defn set-to-zero [ordered-pcset]
  (let [n (first ordered-pcset)]
    (map (fn [x] (if (>= x n)
                   (- x n)
                   (- (+ 12 x) n)))
         ordered-pcset)))
#+END_SRC

#+BEGIN_SRC clojure :session cl-to-cloj
(set-to-zero '(1 2 3 5))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 4 |

** invert-mod12-pcset--called by forte-decision
*** cl--icky
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun invert-mod12-pcset (pcset)
 (sort (mapcan #'mod12 (list (mapcar #'(lambda (x) (- 12 x)) pcset))) #'<))
 #+END_SRC

 #+RESULTS:
 : INVERT-MOD12-PCSET

#+BEGIN_SRC lisp :session cl-to-cloj
(invert-mod12-pcset '(0 3 7 10))
#+END_SRC

#+RESULTS:
| 0 | 2 | 5 | 9 |

*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn invert-mod12-pcset [pcset]
  (sort (mapcat mod12 (list (map #(- 12 %) pcset)))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/invert-mod12-pcset
#+BEGIN_SRC clojure :session cl-to-cloj
(invert-mod12-pcset '(0 3 7 10))
#+END_SRC

#+RESULTS:
| 0 | 2 | 5 | 9 |

** forte-decision--called by forte primeA
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-decision (pcset)
  (let ((a (set-to-zero (find-prime-form-from-list pcset))))
    (list a (set-to-zero (find-prime-form-from-list (invert-mod12-pcset a))))))
 #+END_SRC

 #+RESULTS:
 : FORTE-DECISION
#+BEGIN_SRC lisp :session cl-to-cloj
(mapcar #'forte-decision '((0 1 5 6 8) (0 1 5 7 8) (0 2 3 6 7 9) (0 1 4 5 7 9) (0 1 3 5 8 9) (0 1 4 6 8 9) (0 1 2 5 6 7 9) (0 1 3 4 5 7 8 10)))
#+END_SRC

#+RESULTS:
| (0 1 3 7 8)        | (0 1 5 7 8)        |
| (0 1 5 7 8)        | (0 1 3 7 8)        |
| (0 1 3 6 8 9)      | (0 1 3 6 8 9)      |
| (0 1 3 5 8 9)      | (0 1 4 6 8 9)      |
| (0 1 3 5 8 9)      | (0 1 4 6 8 9)      |
| (0 1 4 6 8 9)      | (0 1 3 5 8 9)      |
| (0 1 2 4 7 8 9)    | (0 1 2 5 7 8 9)    |
| (0 1 2 4 5 7 9 10) | (0 1 2 4 5 7 9 10) |
*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn forte-decision [pcset]
  (let [a (set-to-zero (find-prime-form-from-list pcset))]
    (list a (set-to-zero (find-prime-form-from-list (invert-mod12-pcset a))))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/forte-decision
#+BEGIN_SRC clojure :session cl-to-cloj
(map #'forte-decision '((0 1 5 6 8) (0 1 5 7 8) (0 2 3 6 7 9) (0 1 4 5 7 9) (0 1 3 5 8 9) (0 1 4 6 8 9) (0 1 2 5 6 7 9) (0 1 3 4 5 7 8 10)))
#+END_SRC

#+RESULTS:
| (0 1 3 7 8)        | (0 1 5 7 8)        |
| (0 1 5 7 8)        | (0 1 3 7 8)        |
| (0 1 3 6 8 9)      | (0 1 3 6 8 9)      |
| (0 1 3 5 8 9)      | (0 1 4 6 8 9)      |
| (0 1 3 5 8 9)      | (0 1 4 6 8 9)      |
| (0 1 4 6 8 9)      | (0 1 3 5 8 9)      |
| (0 1 2 4 7 8 9)    | (0 1 2 5 7 8 9)    |
| (0 1 2 4 5 7 9 10) | (0 1 2 4 5 7 9 10) |

** another-forte--called by forte primeA
*** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun another-forte (setx sety)
  (let ((a setx) (b sety))
    (labels ((rec (set1 set2)
	       (cond ((null set1) setx)
		     ((> (car set1) (car set2)) sety)
		     ((< (car set1) (car set2)) setx)
		     (t (rec (cdr set1) (cdr set2))))))
      (rec a b))))
 #+END_SRC

 #+RESULTS:
 : ANOTHER-FORTE

#+BEGIN_SRC lisp :session cl-to-cloj
(another-forte ' (0 1 3 7 8) ' (0 1 5 7 8))
#+END_SRC

#+RESULTS:
| 0 | 1 | 3 | 7 | 8 |
*** clj									:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn another-forte [setx sety]
  (let [a setx b sety]
    (letfn [(rec [set1 set2]
              (cond (empty? set1) setx
                    (> (first set1) (first set2)) sety
                    (< (first set1) (first set2)) setx
                    :else (rec (rest set1) (rest set2))))]
      (rec a b))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/another-forte

#+BEGIN_SRC clojure :session cl-to-cloj
(another-forte ' (0 1 3 7 8) ' (0 1 5 7 8))
#+END_SRC

#+RESULTS:
| 0 | 1 | 3 | 7 | 8 |

** forte-primeA--called by multiset-forte-primeA
*** theory background on what forte-primeA is doing
forte-primeA appears to take any single set of pitch-classes,
transposed and inverted or not, and then returns a pcset, which should
be the prime form according to the forte rules. To see the disputed
sets in the rahn vs. forte

http://www.mta.ca/faculty/arts-letters/music/pc-set_project/pc-set_new/pages/pc-table/packed.html

http://composertools.com/Tools/PCSets/desc_alg.html

| forte name | packed from right | packed to the left |
|       5-20 | (01568)           | (01378)            |
|      6-Z29 | (023679)          | (013689)           |
|       6-31 | (014579)          | (013589)           |
|      7-z18 | (0145679)         | (0234589)          |
|       7-20 | (0125679)         | (0124789)          |
|       8-26 | (0134578T)        | (0124579T)         |

| Pitch Class Set | Forte Prime        | Rahn Prime         |
|            5-20 | (0,1,3,7,8)        | (0,1,5,6,8)        |
|           6-Z29 | (0,1,3,6,8,9)      | (0,2,3,6,7,9)      |
|            6-31 | (0,1,3,5,8,9)      | (0,1,4,5,7,9)      |
|            7-20 | (0,1,2,4,7,8,9)    | (0,1,2,5,6,7,9)    |
|            8-26 | (0,1,2,4,5,7,9,10) | (0,1,3,4,5,7,8,10) |

*** implementations
**** cl
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-primeA (pcset)
  (let ((a (forte-decision pcset)))
    (another-forte (car a) (cadr a))))
 #+END_SRC

 #+RESULTS:
 : FORTE-PRIMEA
#+BEGIN_SRC lisp :session cl-to-cloj
(forte-primeA ' (0 1 5 7 8))
#+END_SRC

#+RESULTS:
| 0 | 1 | 3 | 7 | 8 |
**** clj								:clj:
#+BEGIN_SRC clojure :session cl-to-cloj
(defn forte-primeA [pcset]
  (let [a (forte-decision pcset)]
    (another-forte (first a) (second a))))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/forte-primeA

#+BEGIN_SRC clojure :session cl-to-cloj
(forte-primeA ' (0 1 5 7 8))
#+END_SRC

#+RESULTS:
| 0 | 1 | 3 | 7 | 8 |

** multiset-forte-primeA--called once by IMSET-DECISION-MAKER; used as a "database"
*** detailed explanation, part of imset-decision-maker
Becuase of how multiset-forte-primeA is called within the context of
imset-decision-maker, it expects to receive its argument already
processed by clean profile. 

Huh? 

It's argument will be the first (multi)set produced by a long chain of
functions on the given paired list.

Here's that chain made explicit.

#+BEGIN_SRC lisp :session cl-to-cloj
(let ((paired-list (list '(0 1) '(0 1 2))))
(make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X (first paired-list) (second paired-list))))
#+END_SRC

#+RESULTS:
| (0 1) | (0 1 2)   |
| (0 1) | (1 2 3)   |
| (0 1) | (2 3 4)   |
| (0 1) | (3 4 5)   |
| (0 1) | (4 5 6)   |
| (0 1) | (5 6 7)   |
| (0 1) | (6 7 8)   |
| (0 1) | (7 8 9)   |
| (0 1) | (8 9 10)  |
| (0 1) | (9 10 11) |
| (0 1) | (10 11 0) |
| (0 1) | (11 0 1)  |

This one take a long time, hmm?
#+BEGIN_SRC lisp :session cl-to-cloj
(let* ((paired-list (list '(0 1) '(0 1 2)))
       (b (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X (first paired-list) (second paired-list)))))
       (c (reverse b))
       (d (append b c)))
  d)
#+END_SRC

#+RESULTS:
| 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 |
| 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 |
| 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 |
| 0 | 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 |
| 0 | 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 |
| 0 | 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 | 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 2 | 2 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |


#+BEGIN_SRC lisp :session cl-to-cloj
(let* ((paired-list (list '(0 1) '(0 1 2)))
       (b (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X (first paired-list) (second paired-list)))))
       (c (reverse b))
       (d (append b c))
       (e (mapcar #'clean-profile d)))
  e)
#+END_SRC

#+RESULTS:
| 0 | 0 |  1 |  1 |  2 | 11 |
| 0 | 1 |  1 |  2 |  2 |  3 |
| 1 | 2 |  2 |  3 |  3 |  4 |
| 2 | 3 |  3 |  4 |  4 |  5 |
| 3 | 4 |  4 |  5 |  5 |  6 |
| 4 | 5 |  5 |  6 |  6 |  7 |
| 5 | 6 |  6 |  7 |  7 |  8 |
| 6 | 7 |  7 |  8 |  8 |  9 |
| 7 | 8 |  8 |  9 |  9 | 10 |
| 8 | 9 |  9 | 10 | 10 | 11 |
| 0 | 9 | 10 | 10 | 11 | 11 |
| 0 | 0 |  1 | 10 | 11 | 11 |
| 0 | 0 |  1 | 10 | 11 | 11 |
| 0 | 9 | 10 | 10 | 11 | 11 |
| 8 | 9 |  9 | 10 | 10 | 11 |
| 7 | 8 |  8 |  9 |  9 | 10 |
| 6 | 7 |  7 |  8 |  8 |  9 |
| 5 | 6 |  6 |  7 |  7 |  8 |
| 4 | 5 |  5 |  6 |  6 |  7 |
| 3 | 4 |  4 |  5 |  5 |  6 |
| 2 | 3 |  3 |  4 |  4 |  5 |
| 1 | 2 |  2 |  3 |  3 |  4 |
| 0 | 1 |  1 |  2 |  2 |  3 |
| 0 | 0 |  1 |  1 |  2 | 11 |

#+BEGIN_SRC lisp :session cl-to-cloj
(let* ((paired-list (list '(0 1) '(0 1 2)))
       (b (mapcar #'createA-lewin-vector (make-pairs-from-list (set-up-Tn-equivalent-Ys-with-X (first paired-list) (second paired-list)))))
       (c (reverse b))
       (d (append b c))
       (e (mapcar #'clean-profile d))
       (f (multiset-forte-primeA (first e))))
       f)
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 |

*** cl

 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-primeA (mset)
 (forte-primeA (remove-duplicates mset)))
 #+END_SRC

 #+RESULTS:
 : MULTISET-FORTE-PRIMEA

#+BEGIN_SRC lisp :session cl-to-cloj
(multiset-forte-primeA '((0 1 2 11) (0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (4 5 6 7) (5 6 7 8) (6 7 8 9) (7 8 9 10) (8 9 10 11) (0 9 10 11) (0 1 10 11) (0 9 10 11) (8 9 10 11) (7 8 9 10) (6 7 8 9) (5 6 7 8) (4 5 6 7) (3 4 5 6) (2 3 4 5) (1 2 3 4) (0 1 2 3) (0 1 2 11) (0 1 10 11)))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 |

*** clj

#+BEGIN_SRC clojure :session cl-to-cloj
(defn multiset-forte-primeA [mset]
(forte-primeA (distinct mset)))
#+END_SRC

#+RESULTS:
: #'post_tonal_overtone.core/multiset-forte-primeA

#+BEGIN_SRC clojure :session cl-to-cloj
(multiset-forte-primeA '(0 0 1 1 2 11))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 |
*** hide noise
**** 
uh, does multiset-forte-primeA really take multisets for its argument?
Yes, call it with the results of some other ~clean-profile~ of lewin
vectors.

also, if forte-primeA requires a single set argument, is being called
with a whole list of lists for a reason?

#+BEGIN_SRC lisp :session cl-to-cloj
(clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 3 | 4 | 4 | 4 | 5 | 5 | 5 | 6 | 6 | 6 | 7 | 7 | 7 | 7 | 7 | 8 | 8 | 8 | 8 | 8 | 8 | 8 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 10 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 | 11 |

#+BEGIN_SRC lisp :session cl-to-cloj
(forte-primeA (clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11)))
#+END_SRC

#+RESULTS:
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 3 | 3 | 3 | 3 | 3 | 3 | 3 | 4 | 4 | 4 | 4 | 4 | 5 | 5 | 5 | 6 | 6 | 6 | 7 | 7 | 7 | 8 | 8 | 9 | 10 | 0 |

#+BEGIN_SRC lisp :session cl-to-cloj
(remove-duplicates (clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11)))
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 10 | 11 |

#+BEGIN_SRC lisp :session cl-to-cloj
(forte-primeA (remove-duplicates (clean-profile '(0 1 1 2 3 3 3 5 7 0 10 11))))
#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 9 | 10 |
** [#B] wrap-vectors--never called
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun wrap-vectors (ordered-set)
  (mapcar #'prime-vector (all-rotations ordered-set)))
 #+END_SRC

 #+RESULTS:
 : WRAP-VECTORS

#+BEGIN_SRC lisp :session cl-to-cloj

#+END_SRC

** [#B] Ainvert-mod12-pcset--called only by a never-called function 
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun Ainvert-mod12-pcset (pcset)
 (mapcan #'mod12 (list (mapcar #'(lambda (x) (- 12 x)) pcset))))
 #+END_SRC

 #+RESULTS:
 : AINVERT-MOD12-PCSET

** [#B] find-set-inversion--never called
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun find-set-inversion (pcset)
  (set-to-zero (reverse (Ainvert-mod12-pcset pcset))))
 #+END_SRC

 #+RESULTS:
 : FIND-SET-INVERSION

** [#B] forte-prime--only called by multiset-forte-prime, which goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun forte-prime (pcset)
  (let ((a (forte-decision pcset)))
    (if (every #'<= (car a) (cadr a))
	(car a)
	(cadr a))))
 #+END_SRC

** [#B] multiset-forte-prime--goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-prime (mset)
 (forte-prime (remove-duplicates mset)))
 #+END_SRC

** [#B] multiset-forte-decision--goes uncalled
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun multiset-forte-decision (mset)
  (forte-decision (remove-duplicates mset)))
 #+END_SRC

 #+RESULTS:
 : MULTISET-FORTE-DECISION

* full documentation separated out for imset-decision-maker
** cl definition
#+BEGIN_SRC lisp :session cl-to-cloj
(defun imset-decision-maker (paired-list)
  (let* (
	 (a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
	 (b (mapcar #'createA-lewin-vector a))
	 (c (mapcar #'reverse b))
	 (d (append b c))
	 (e (mapcar #'clean-profile d)) ; turns out CLEAN-PROFILE effectively creates a Straus-profile
	 (f (multiset-forte-primeA (car e))) ; car because only need check the first one as they
					; all will represent the same forteprime (why, again?)
	 (g (mapcar #'remove-duplicates e))
	 (h (locate f g))
	 (i (loop for idx in (cdr h) ; must use cdr portion of LOCATE output
	       collect (nth (1- idx) e))) ;locate is not zero-indexed apparently
	 (j (remove-duplicates i :test #'equal)))
    (if (<= (length j) 2)
	(if (every #'<= (car j) (cadr j))
	    (car j)
	    (cadr j))
	(locating j))))
#+END_SRC

#+RESULTS:
: IMSET-DECISION-MAKER

#+BEGIN_SRC lisp :session cl-to-cloj
(imset-decision-maker '((0 1) (0 1 3)))
#+END_SRC

#+RESULTS:
| 0 | 1 | 1 | 2 | 3 | 4 |
** clj naive definition

#+BEGIN_SRC clojure :session cl-to-cloj
(defn imset-decision-maker [paired-list]
  (let* (
	 (a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (first paired-list) 
					     (second paired-list))))
	 (b (map createA-lewin-vector a))
	 (c (map reverse b))
	 (d (append b c))
	 (e (map clean-profile d)) ; turns out CLEAN-PROFILE effectively creates a Straus-profile
	 (f (multiset-forte-primeA (car e))) ; car because only need check the first one as they
					; all will represent the same forteprime (why, again?)
	 (g (map remove-duplicates e))
	 (h (locate f g))
	 (i (loop for idx in (cdr h) ; must use cdr portion of LOCATE output
	       collect (nth (1- idx) e))) ;locate is not zero-indexed apparently
	 (j (remove-duplicates i :test equal)))
    (if (<= (length j) 2)
	(if (every <= (car j) (cadr j))
	    (car j)
	    (cadr j))
	(locating j))))
#+END_SRC
* miscellaneous documentation
** streamlined documentation
#+BEGIN_SRC lisp :session cl-to-cloj
(defun imset-decision-maker (paired-list)
  (let* (
	 (a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
	 (b (mapcar #'createA-lewin-vector a))
	 (c (mapcar #'reverse b))
	 (d (append b c))
	 (e (mapcar #'clean-profile d)) ; turns out CLEAN-PROFILE effectively creates a Straus-profile
	 (f (multiset-forte-primeA (car e))) ; car because only need check the first one as they
					; all will represent the same forteprime (why, again?)
	 (g (mapcar #'remove-duplicates e))
	 (h (locate f g))
	 (i (loop for idx in (cdr h) ; must use cdr portion of LOCATE output
	       collect (nth (1- idx) e))) ;locate is not zero-indexed apparently
	 (j (remove-duplicates i :test #'equal)))
    (if (<= (length j) 2)
	(if (every #'<= (car j) (cadr j))
	    (car j)
	    (cadr j))
	(locating j))))
#+END_SRC

** broken up documentation
#+BEGIN_SRC lisp :session cl-to-cloj
	 ;; a is the "home-list", the foundation, providing all the
	 ;; paired sets across the transpositional spectrum for a given
	 ;; X-Y pair
	 (a (make-pairs-from-list 
	     (set-up-Tn-equivalent-Ys-with-X (car paired-list) 
					     (cadr paired-list))))
#+BEGIN_SRC lisp :session cl-to-cloj
;; determine the IFUNC of each X-Y pair in A, where the X chord is 
	 ;; constant and Y is transposed by Tn for n from 0 to 11
	 (b (mapcar #'createA-lewin-vector a))
#+END_SRC
#+BEGIN_SRC lisp :session cl-to-cloj	 
	 ;; also determine the INVERSE of each IFUNC simply
	 ;; at one time by reversing the lewin-vector
	 ;;
	 ;; disadvantage is that you don't get the generating pair
	 ;; explicitly, but still a neat trick on Lewin-style vectors


	 (c (mapcar #'reverse b))
#+END_SRC

#+BEGIN_SRC lisp :session cl-to-cloj
;; make one big list that contains all these
	 ;; lewin-vectors. we will then use this list of 24 IFUNCS in
	 ;; Lewin form to find the preferred prime-form according to the 
	 ;; prime-form algorithm of choice

	 (d (append b c))
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; create the analogous 24 straus-profiles
	 (e (mapcar #'clean-profile d)) ; turns out CLEAN-PROFILE effectively creates a Straus-profile
#+END_SRC
	 

#+BEGIN_SRC lisp :session cl-to-cloj
;; determine the forte prime form that the reduced
	 ;; straus multisets represent
	 ;; 
	 ;; could be replaced with Straus-Rahn algorithm if desired
	 (f (multiset-forte-primeA (car e))) ; car because only need check the first one as they
					     ; all will represent the
	 ;; same forteprime (why, again?)
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; make all imsets into sets in order to perform
	 ;; some nifty LOCATE-ing maneuvers

	 (g (mapcar #'remove-duplicates e))
#+END_SRC
	 

#+BEGIN_SRC lisp :session cl-to-cloj
;; find the location(s) of the forte prime in this 
	 ;; new list of sets
	 ;;
	 ;; NB. F is a shallow list, and contains the only the single prime-form
	 (h (locate f g))
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; IMPORTANT: use the location of 
	 ;; prime-form f in the list of sets g
	 ;; to find the generating multiset parent(s) in e
	 ;; possible that there is MORE THAN ONE!
	 (i (loop for idx in (cdr h) ; must use cdr portion of LOCATE output
	       collect (nth (1- idx) e))) ;locate is not zero-indexed apparently
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
;; leave only unique representatives generators of the
	 ;; forte-prime form. at max there should be two 
	 ;;
	 ;; NOT NECESSARILY!!! see ((0 2 4) (0 2 6)) 
	 (j (remove-duplicates i :test #'equal))
#+END_SRC
	 
#+BEGIN_SRC lisp :session cl-to-cloj
    ;; following code commented out because it failed to 
    ;; detect the prime form in the specific tricky case 
    ;; mentioned just above. otherwise, a hack worth
    ;; looking at, at least for its use of EVERY
    ;;
    ;; (if (every #'<= (car j) (cadr j))
    ;; 	(list 'first j)
    ;; 	(list 'second j))
    ;;
	 ;;; this alone just cannot do it.
	 ;;; there must be a larger function for looking 
	 ;;; within multiset families--update: that is now
	 ;;; done by the function, LOCATING below
#+END_SRC

#+BEGIN_SRC lisp :session cl-to-cloj
    ;; do pairwise comparisons to find the imset that 
    ;; most consistently is lower from left to right
    ;; and use LOCATING in the special case
    ;;
    ;; in compilation this won't print but use for seeing
    ;; step by step the process here
    ;;
    ;; (format t "~{~{~a ~%~}~%~}" (list a d e f g h i j))

(if (<= (length j) 2)
	(if (every #'<= (car j) (cadr j))
	    (car j)
	    (cadr j))
	(locating j))
#+END_SRC


** locate is uncalled??
 #+BEGIN_SRC lisp :session cl-to-cloj
(defun map-locate (loli)
  (let ((full-list loli))
   (labels ((hmm (rec-loli)
	      (cond ((null rec-loli) ())
		    (t (cons (locate (car rec-loli) full-list)
			     (hmm (cdr rec-loli)))))))
     (hmm loli))))
 #+END_SRC

** massive full unexpurgated function composition--up to comparing length of results
the whole ~j~ step diversion must be due to special situations that
need to be documented. The proverbial corner cases...
#+BEGIN_SRC lisp :session cl-to-cloj

;;; used to check the 'j' step
(length
 (remove-duplicates
  (loop for idx in
       (cdr (locate
	     (multiset-forte-primeA
	      (car (mapcar #'clean-profile
			   (append
			    (mapcar #'createA-lewin-vector
				    (make-pairs-from-list 
				     (set-up-Tn-equivalent-Ys-with-X '(0 1) 
								     '(0 2))))
			    (mapcar #'reverse
				    (mapcar #'createA-lewin-vector
					    (make-pairs-from-list 
					     (set-up-Tn-equivalent-Ys-with-X '(0 1) 
									     '(0 2)))))))))
	     (mapcar #'remove-duplicates
		     (mapcar #'clean-profile
			     (append  (mapcar #'createA-lewin-vector
					      (make-pairs-from-list 
					       (set-up-Tn-equivalent-Ys-with-X '(0 1) 
									       '(0 2))))
				      (mapcar #'reverse
					      (mapcar #'createA-lewin-vector
						      (make-pairs-from-list 
						       (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										       '(0 2))))))))))
     collect (nth (1- idx)
		  (mapcar #'clean-profile
			  (append  (mapcar #'createA-lewin-vector
					   (make-pairs-from-list 
					    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
									    '(0 2))))
				   (mapcar #'reverse
					   (mapcar #'createA-lewin-vector
						   (make-pairs-from-list 
						    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										    '(0 2)))))))) ) :test #'equal))

;; 1

(remove-duplicates (loop for idx in (cdr (locate (multiset-forte-primeA (car (mapcar #'clean-profile
										     (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
															      (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																			      '(0 2))))
											      (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
																		(set-up-Tn-equivalent-Ys-with-X '(0 1) 
																						'(0 2)))))))))
						 (mapcar #'remove-duplicates
							 (mapcar #'clean-profile
								 (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
													  (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																	  '(0 2))))
									  (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
															    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																			    '(0 2))))))))))
		      collect (nth (1- idx) (mapcar #'clean-profile
						    (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
											     (set-up-Tn-equivalent-Ys-with-X '(0 1) 
															     '(0 2))))
							     (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
													       (set-up-Tn-equivalent-Ys-with-X '(0 1) 
																	       '(0 2)))))))) ) :test #'equal)

;; ((0 1 2 3))

(loop for idx in (cdr (locate (multiset-forte-primeA (car (mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))))
	(mapcar #'remove-duplicates
	(mapcar #'clean-profile
		(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
							 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
											 '(0 2))))
			 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
									   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													   '(0 2))))))))))
   collect (nth (1- idx) (mapcar #'clean-profile
				 (append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
									  (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													  '(0 2))))
					  (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
											    (set-up-Tn-equivalent-Ys-with-X '(0 1) 
															    '(0 2)))))))) )

;; ((0 1 2 3) (0 1 2 3))

(locate (multiset-forte-primeA (car (mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))))
	(mapcar #'remove-duplicates
	(mapcar #'clean-profile
		(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
							 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
											 '(0 2))))
			 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
									   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													   '(0 2)))))))))

;; ((0 1 2 3) 2 22)

(mapcar #'remove-duplicates
	(mapcar #'clean-profile
		(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
							 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
											 '(0 2))))
			 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
									   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
													   '(0 2))))))))

;; ((0 1 2 11) (0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (4 5 6 7) (5 6 7 8) (6 7 8 9) (7 8 9 10) (8 9 10 11) (0 9 10 11) (0 1 10 11) (0 9 10 11) (8 9 10 11) (7 8 9 10) (6 7 8 9) (5 6 7 8) (4 5 6 7) (3 4 5 6) (2 3 4 5) (1 2 3 4) (0 1 2 3) (0 1 2 11) (0 1 10 11))

(multiset-forte-primeA (car (mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))))

;; (0 1 2 3)

(mapcar #'clean-profile
	(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
						 (set-up-Tn-equivalent-Ys-with-X '(0 1) 
										 '(0 2))))
		 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
								   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
												   '(0 2)))))))
;; ((0 1 2 11) (0 1 2 3) (1 2 3 4) (2 3 4 5) (3 4 5 6) (4 5 6 7) (5 6 7 8) (6 7 8 9) (7 8 9 10) (8 9 10 11) (0 9 10 11) (0 1 10 11) (0 9 10 11) (8 9 10 11) (7 8 9 10) (6 7 8 9) (5 6 7 8) (4 5 6 7) (3 4 5 6) (2 3 4 5) (1 2 3 4) (0 1 2 3) (0 1 2 11) (0 1 10 11))

(append  (mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2))))
	 (mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2))))))
;;((1 1 1 0 0 0 0 0 0 0 0 1) (1 1 1 1 0 0 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 0 0 1 1 1 1) (1 0 0 0 0 0 0 0 0 1 1 1) (1 1 0 0 0 0 0 0 0 0 1 1) (1 0 0 0 0 0 0 0 0 1 1 1) (0 0 0 0 0 0 0 0 1 1 1 1) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (1 1 1 1 0 0 0 0 0 0 0 0) (1 1 1 0 0 0 0 0 0 0 0 1) (1 1 0 0 0 0 0 0 0 0 1 1))

(mapcar #'reverse (mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2)))))

;;((1 0 0 0 0 0 0 0 0 1 1 1) (0 0 0 0 0 0 0 0 1 1 1 1) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (1 1 1 1 0 0 0 0 0 0 0 0) (1 1 1 0 0 0 0 0 0 0 0 1) (1 1 0 0 0 0 0 0 0 0 1 1))

(mapcar #'createA-lewin-vector (make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2))))

;;((1 1 1 0 0 0 0 0 0 0 0 1) (1 1 1 1 0 0 0 0 0 0 0 0) (0 1 1 1 1 0 0 0 0 0 0 0) (0 0 1 1 1 1 0 0 0 0 0 0) (0 0 0 1 1 1 1 0 0 0 0 0) (0 0 0 0 1 1 1 1 0 0 0 0) (0 0 0 0 0 1 1 1 1 0 0 0) (0 0 0 0 0 0 1 1 1 1 0 0) (0 0 0 0 0 0 0 1 1 1 1 0) (0 0 0 0 0 0 0 0 1 1 1 1) (1 0 0 0 0 0 0 0 0 1 1 1) (1 1 0 0 0 0 0 0 0 0 1 1))

(make-pairs-from-list 
   (set-up-Tn-equivalent-Ys-with-X '(0 1) 
				   '(0 2)))

;;(((0 1) (0 2)) ((0 1) (1 3)) ((0 1) (2 4)) ((0 1) (3 5)) ((0 1) (4 6)) ((0 1) (5 7)) ((0 1) (6 8)) ((0 1) (7 9)) ((0 1) (8 10)) ((0 1) (9 11)) ((0 1) (10 0)) ((0 1) (11 1)))

;;;; HUGE! Make all the pairings of two sets, X and transposed version of Y
(set-up-Tn-equivalent-Ys-with-X '(0 1) '(0 2))
;; ((0 1) (0 2) (0 1) (1 3) (0 1) (2 4) (0 1) (3 5) (0 1) (4 6) (0 1) (5 7) (0 1) (6 8) (0 1) (7 9) (0 1) (8 10) (0 1) (9 11) (0 1) (10 0) (0 1) (11 1))



#+END_SRC
